<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2021-04-10T14:50:37.206Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[JPAでパラメータで変数の値を渡す方法]]></title>
        <id>https://zy080080.github.io/post/A2C8pQJ7y/</id>
        <link href="https://zy080080.github.io/post/A2C8pQJ7y/">
        </link>
        <updated>2021-04-10T15:46:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
<!-- more -->
<p><img src="https://zy080080.github.io//post-images/1618066009899.png" alt="" loading="lazy"><br>
図で示したように，「?変数の番号」で渡すことができる</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring AOPにおけるPointcut式例]]></title>
        <id>https://zy080080.github.io/post/RmuKwXL0F/</id>
        <link href="https://zy080080.github.io/post/RmuKwXL0F/">
        </link>
        <updated>2021-03-22T03:28:30.000Z</updated>
        <summary type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
]]></summary>
        <content type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
<!-- more -->
<pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
</code></pre>
<p>publicメソッドの実行</p>
<pre><code>execute(public * *(..))
</code></pre>
<p>setで始まる名前のメソッドの実行</p>
<pre><code>execution(* set*(..))
</code></pre>
<p>AccountServiceインターフェースによって定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.AccountService.*(..))
</code></pre>
<p>serviceパッケージで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.*.*(..))
</code></pre>
<p>サービスパッケージまたはそのサブパッケージのいずれかで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service..*.*(..))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatisを始める：Quick Start]]></title>
        <id>https://zy080080.github.io/post/kk4jq6fpX/</id>
        <link href="https://zy080080.github.io/post/kk4jq6fpX/">
        </link>
        <updated>2021-03-13T12:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
<!-- more -->
<h2 id="installation">Installation</h2>
<p>Mavenを利用する場合は下記の依存性を追加する。もしくは，mybatis-x.x.x.jarをクラスパスに追加する必要がある。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupID&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="xml形式の設定ファイルを使ってsqlsessionfactoryを生成する">XML形式の設定ファイルを使ってSqlSessionFactoryを生成する</h2>
<p>Mybatisアプリケーションは，SqlSessionFactoryのインスタンスを中心に構成されている。<br>
SqlSessionFactoryのインスランスは，SqlSessionFactoryBuilderを使って取得することができる。<br>
SqlSessionFactoryBuilderがSqlSessionFactoryを生成する際の設定は，XML形式の設定ファイルを読み込むか，独自に用意したConfigurationクラスのインスタンスを渡すことで行う。</p>
<pre><code>String resource = &quot;mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</code></pre>
<p>XML形式の設定ファイルには，Mybatisシステムの基本設定が含まれる。例えば，データベースからConnectionのインスタンスを取得するDataSourceや，トランザクションの制御方法を決定するTransactionManagerなどである。</p>
<p>簡単なサンプル：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;enviroments default=&quot;development&quot;&gt;
        &lt;enviroment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/databaseName?characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;123&quot;&gt;
            &lt;/dataSource&gt;
        &lt;/enviroments&gt;
    &lt;/enviroments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/xxx/xxx/MapperName.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>enviroment要素には，トランザクション管理やコネクションプーリングといった環境依存の設定が含まれている。<br>
mapper要素にはMapperのリストが含まれている。Mapperとは，SQL文とマッピングの定義を含むXMLファイルである。</p>
<h2 id="mapped-sql-statementsについて">Mapped SQL Statementsについて</h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
　PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
　&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>１つのMapper XMLファイルに複数のMapped Statementを定義することができるので，XMLヘッダやdoctype宣言は一度書く。<br>
「org.mybatis.example.BlogMapper」というネームスペース中に「selectBlog」という名前のMapped Statementを定義している。</p>
<p>このMapped Statementを実行するには，以下のように完全修飾名「org.mybatis.example.BlogMapper.selectBlog」を指定してSqlSessionのメソッドを呼び出す。</p>
<pre><code>Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);
</code></pre>
<p>ただし，mybatis-config.xmlに，typeAliasesを追加すれば，完全修飾名を使わずに済む。</p>
<pre><code>&lt;configuration&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.how2java.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;enviroments&gt;
    ...
&lt;/configuration&gt;
</code></pre>
<h2 id="スコープとライフサイクル">スコープとライフサイクル</h2>
<h3 id="sqlsessionfactorybuilder">SqlSessionFactoryBuilder</h3>
<p>このクラスは，インスタンス化し，使用し，破壊することができる。一旦SqlSessionFactoryを生成してしまえば，このクラスを残しておく理由はない。したがって，このクラスのスコープとして最適なのは<strong>メソッドスコープ</strong>（つまり，ローカルメソッド変数）である。<br>
SqlSessionFactoryBuilderを再利用して複数のSqlSessionFactoryを生成することも可能だが，XMLをパースするためのリソースが他の重要なものを圧迫しないように，このクラスを保持して使いまわさない方が得策である。</p>
<h3 id="sqlsessionfactory">SqlSessionFactory</h3>
<p>生成したSqlSessionFactoryは，あなたのアプリケーション実行中はそのまま残しておくべきである。生成したSqlSessionFactoryを破棄したり，再度生成する理由はないはずである。したがって，SqlSessionFactoryに最適なのは<strong>アプリケーションスコープ</strong>である。これを実現する方法はいくつもある。もっとも簡単なのはシングルトンパターンまたはスタティックシングルトンパターンを使う方法である。</p>
<h3 id="sqlsession">SqlSession</h3>
<p>各スレッドは，独立したSqlSessionのインスタンスを使うべきである。SqlSessionのインスタンスは共有されることを前提としていないため，スレッドセーフではない。当然，最適なスコープは<strong>メソッドスコープ</strong>になる。SqlSessionのインスタンスへの参照をstaticなフィールドや，インスタンスフィールドにも格納してはいけない。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zy080080.github.io/post/8IAmAkZZ0/</id>
        <link href="https://zy080080.github.io/post/8IAmAkZZ0/">
        </link>
        <updated>2021-02-26T08:27:18.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
<!-- more -->
<h2 id="第六章-过滤数据">第六章 过滤数据</h2>
<h3 id="61-使用where子句">6.1 使用WHERE子句</h3>
<pre><code>SELECT prod_name prod_price
FROM products
WHERE prod_price = 2.50;
</code></pre>
<h3 id="62-where子句操作符">6.2 WHERE子句操作符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN ... AND ...</td>
<td style="text-align:left">在指定两值之间</td>
</tr>
</tbody>
</table>
<h4 id="621-~-623">6.2.1 ~ 6.2.3</h4>
<p>测试表格操作符</p>
<h4 id="624-控制检查">6.2.4 控制检查</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_price IS NULL

SELECT prod_name
FROM products
WHERE prod_price IS NOT NULL
</code></pre>
<h2 id="第七章-数据过滤">第七章 数据过滤</h2>
<h3 id="71-组合where子句">7.1 组合WHERE子句</h3>
<h4 id="711-and操作符">7.1.1 AND操作符</h4>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1003 AND prod_price &lt;= 10;
</code></pre>
<h4 id="712-or操作符">7.1.2 OR操作符</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
</code></pre>
<h4 id="713-计算次序">7.1.3 计算次序</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;
</code></pre>
<p>在WHERE子句中使用圆括号：<br>
任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。</p>
<h3 id="73-in操作符">7.3 IN操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002, 1003)
ORDER BY prod_name;
</code></pre>
<p>此语句与使用OR时具有相同的功能</p>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003
ORDER BY prod_name;
</code></pre>
<p>使用IN操作符的优点：</p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚而且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句（详见14章）。</li>
</ul>
<h3 id="73-not操作符">7.3 NOT操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id NOT IN (1002,1003)
ORDER BY prod_name;
</code></pre>
<h2 id="第八章-用通配符进行过滤">第八章 用通配符进行过滤</h2>
<h3 id="81-like操作符">8.1 LIKE操作符</h3>
<h4 id="811-百分号通配符">8.1.1 百分号通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 'jet%';
</code></pre>
<p>搜索jet起头的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '%anvil%';
</code></pre>
<p>搜索含有anvil的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 's%e';
</code></pre>
<p>搜索s开头e结尾的词</p>
<p>注意：<br>
%不能匹配NULL</p>
<h4 id="812-下划线通配符">8.1.2 下划线通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '_ ton anvil';
</code></pre>
<p>_总是匹配一个字符</p>
<h3 id="82-使用通配符的技巧">8.2 使用通配符的技巧</h3>
<p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>除非绝对有必要，否则不要把它们用在搜索模式的开始处。放在开始处的搜索是最慢的。</li>
<li>仔细注意通配符的位置。</li>
</ul>
<h2 id="第九章-使用正则表达式">第九章 使用正则表达式</h2>
<h3 id="92-使用mysql正则表达式">9.2 使用MySQL正则表达式</h3>
<h4 id="921-基本字符匹配">9.2.1 基本字符匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name;
</code></pre>
<p>查询含有1000的名称</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '.000'
ORDER BY prod_name;
</code></pre>
<h4 id="922-进行or匹配">9.2.2 进行OR匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000|2000'
ORDER BY prod_name;
</code></pre>
<h4 id="923-匹配几个字符之一">9.2.3 匹配几个字符之一</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="924-匹配范围">9.2.4 匹配范围</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[1-5] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="925-匹配特殊字符">9.2.5 匹配特殊字符</h4>
<pre><code>SELECT vend_name
FROM vendors
WHERE vend_name REGEXP '\\.'
ORDER BY vend_name;
</code></pre>
<p>为了匹配反斜杠（\）字符本身，要用\\。</p>
<p>MySQL要求两个反斜杠，MySQL自己解释一个，正则表达式库解释另一个。</p>
<h4 id="926-匹配字符类">9.2.6 匹配字符类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td>ASCII控制字符（ASCII0到31和127）</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td>任意小写字母（同[:lower:]）</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td>任意十六进制数字（同a-fA-F0-9）</td>
</tr>
</tbody>
</table>
<h4 id="927-匹配多个实例">9.2.7 匹配多个实例</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（同{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或一个匹配（同{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\([0-9] sticks?\\)'
ORDER BY prod_name;

SELECT prod_name
FROM products
WHERE prod_name REGEXP '[[:digit:]]{4}'
ORDER BY prod_name;
</code></pre>
<p>四个连续的数字，与下面的写法相同</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[0-9][0-9][0-9][0-9]'
ORDER BY prod_name;
</code></pre>
<h4 id="928-定位符">9.2.8 定位符</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '^[0-9\\.]'
ORDER BY prod_name;
</code></pre>
<p>LIKE匹配整个串而REGEXP匹配子串。</p>
<h2 id="第十章-创建拼接字段">第十章 创建拼接字段</h2>
<h3 id="102-拼接字段">10.2 拼接字段</h3>
<pre><code>SELECT Concat(vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;

SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')')
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>RTrim() 去除右边空格<br>
LTrim() 去除左边空格<br>
Trim()  去除两边空格</p>
<pre><code>SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') AS vend_title
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>赋予新计算列别名</p>
<h3 id="103-执行算数计算">10.3 执行算数计算</h3>
<pre><code>SELECT prod_id, quantity, item_price, quantity*item_price AS enpanded_price
FROM orderitems
WHERE order_num = 20005;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
<h2 id="第十一章-使用数据处理函数">第十一章 使用数据处理函数</h2>
<h3 id="112-使用函数">11.2 使用函数</h3>
<h4 id="1121-文本处理函数">11.2.1 文本处理函数</h4>
<pre><code>SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
</code></pre>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody>
</table>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX不是SQL概念，但MySQL提供对其的支持。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE cust_contact = 'Y. Lie';
</code></pre>
<p>此句不会搜索出'Y Lee'，但使用SOUNDEX可搜索出。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE Soundex(cust_contact) = Soundex('Y Lie');
</code></pre>
<h4 id="1122-日期和时间处理函数">11.2.2 日期和时间处理函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddDate()</td>
<td>增加一个日期（天，周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时，分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<p>日期格式必须为yyyy-mm-dd</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
</code></pre>
<p>更可靠的语句：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
</code></pre>
<p>搜索某月的全部订单：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
</code></pre>
<p>或者</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[デバッガコマンド]]></title>
        <id>https://zy080080.github.io/post/uDwPfDRbx/</id>
        <link href="https://zy080080.github.io/post/uDwPfDRbx/">
        </link>
        <updated>2021-02-15T08:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>gdb Filename.exe</p>
<table>
<thead>
<tr>
<th style="text-align:left">コマンド</th>
<th style="text-align:left">略称</th>
<th style="text-align:left">例</th>
<th style="text-align:left">例示コマンドの機能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">quit</td>
<td style="text-align:left">q</td>
<td style="text-align:left">q</td>
<td style="text-align:left">デバッガを終了</td>
</tr>
<tr>
<td style="text-align:left">help</td>
<td style="text-align:left">h</td>
<td style="text-align:left">h list</td>
<td style="text-align:left">コマンドの説明</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">file</td>
<td style="text-align:left">file e4-3-x64-g.exe</td>
<td style="text-align:left">デバッグ対象を指定</td>
</tr>
<tr>
<td style="text-align:left">set logging</td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging file e4-3a-x64g.log</td>
<td style="text-align:left">ログファイル名を変更</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging overwrite</td>
<td style="text-align:left">ログファイル上書き指定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging overwrite off</td>
<td style="text-align:left">ログファイル追記指定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging on</td>
<td style="text-align:left">ログ記録の有効化</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging off</td>
<td style="text-align:left">ログ記録の無効化</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left"></td>
<td style="text-align:left">target remote:1234</td>
<td style="text-align:left">通信ポート1234を使い遠隔端末に接続</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">l</td>
<td style="text-align:left">l main</td>
<td style="text-align:left">関数mainのコードを10行表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">l</td>
<td style="text-align:left">次の10行表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">l 10</td>
<td style="text-align:left">ソースコードの10行目前後を表示</td>
</tr>
<tr>
<td style="text-align:left">info</td>
<td style="text-align:left">i</td>
<td style="text-align:left">i register</td>
<td style="text-align:left">全レジスタの内容を表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">i register $eax</td>
<td style="text-align:left">レジスタeaxを表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">i break</td>
<td style="text-align:left">ブレークポイントを一覧表示</td>
</tr>
<tr>
<td style="text-align:left">backtrace</td>
<td style="text-align:left">bt</td>
<td style="text-align:left">bt</td>
<td style="text-align:left">バックトレースしスタックフレーム表示</td>
</tr>
<tr>
<td style="text-align:left">disas</td>
<td style="text-align:left"></td>
<td style="text-align:left">disas</td>
<td style="text-align:left">実行中の関数のコードを逆アセンブル</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">disas max3</td>
<td style="text-align:left">関数max3のコードを逆アセンブル</td>
</tr>
<tr>
<td style="text-align:left">where</td>
<td style="text-align:left"></td>
<td style="text-align:left">where</td>
<td style="text-align:left">中断地点を表示</td>
</tr>
<tr>
<td style="text-align:left">run</td>
<td style="text-align:left">r</td>
<td style="text-align:left">r</td>
<td style="text-align:left">プログラムを実行開始</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">r 3 5</td>
<td style="text-align:left">コマンドライン引数(3,5)を指定してプログラムを実行開始</td>
</tr>
<tr>
<td style="text-align:left">break</td>
<td style="text-align:left">b</td>
<td style="text-align:left">b main</td>
<td style="text-align:left">関数mainの先頭にブレイクポイントを設定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">b 10</td>
<td style="text-align:left">10行目にブレイクポイントを設定</td>
</tr>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">d</td>
<td style="text-align:left">d 2</td>
<td style="text-align:left">2番目のブレイクポイントを解除</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">d</td>
<td style="text-align:left">全ブレイクポイントを解除</td>
</tr>
<tr>
<td style="text-align:left">continue</td>
<td style="text-align:left">c</td>
<td style="text-align:left">c</td>
<td style="text-align:left">中断中のプログラムの実行再開</td>
</tr>
<tr>
<td style="text-align:left">step</td>
<td style="text-align:left">s</td>
<td style="text-align:left">s</td>
<td style="text-align:left">1ステップ（１命令）実行</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">s 10</td>
<td style="text-align:left">10ステップ（10命令）実行</td>
</tr>
<tr>
<td style="text-align:left">display/fmt</td>
<td style="text-align:left">disp</td>
<td style="text-align:left">display/x $eax</td>
<td style="text-align:left">中断ごとにレジスタeaxの値を16進数表示する</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">disp/t a1</td>
<td style="text-align:left">中断ごとに変数a1の値を2進数表示</td>
</tr>
<tr>
<td style="text-align:left">x/fmt</td>
<td style="text-align:left">x</td>
<td style="text-align:left">x/x　0x400606</td>
<td style="text-align:left">0x400606番地から4バイトを16進数表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">x/t $eax</td>
<td style="text-align:left">レジスタeaxの値を2進数表示</td>
</tr>
<tr>
<td style="text-align:left">print/fmt</td>
<td style="text-align:left">p</td>
<td style="text-align:left">p/x $eax</td>
<td style="text-align:left">レジスタeaxの値を16進数表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">p i</td>
<td style="text-align:left">変数iの値を10進数表示</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left"></td>
<td style="text-align:left">set v1 = 10</td>
<td style="text-align:left">変数v1の値を10にする</td>
</tr>
</tbody>
</table>
<p>fmt：書式指定</p>
<ul>
<li>t:2進数</li>
<li>o:8進数</li>
<li>d:10進数</li>
<li>x:16進数</li>
<li>c:文字</li>
<li>f:浮動小数店</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：ファイルーより進んだファイルシステム]]></title>
        <id>https://zy080080.github.io/post/PXPlWYWB9/</id>
        <link href="https://zy080080.github.io/post/PXPlWYWB9/">
        </link>
        <updated>2021-01-19T02:18:24.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第14章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第14章　まとめ</p>
<!-- more -->
<p><strong>ライトスルー</strong>：書き込み発生時，ディスクに対しても書き込みを行う。</p>
<p><strong>ライトバック</strong>：書き込み発生時はディスクキャッシュに対してのみ行う。定期的に（数十秒程度）キャッシュの内容を二次記憶にい書き出す。</p>
<p><strong>ジャーナルファイルシステム</strong>：</p>
<ul>
<li>**二次記憶の一部（固定領域）**をジャーナル領域とする</li>
<li>書き込み時
<ul>
<li>ジャーナル領域に，下記の情報を書き込む。
<ul>
<li>空きセクタ確保情報</li>
<li>inode（ファイル、ディレクトリなどのファイルシステム上のオブジェクトに関する基本情報が格納される）確保・更新情報</li>
<li>セクタ書き込み情報</li>
<li>ディレクトリ更新情報</li>
</ul>
</li>
<li>書き込み終了後，プロセスに書き込み完了通知（commit）</li>
<li>非同期に，ジャーナル領域にあるファイル変更情報を用いて，ファイル実体を更新</li>
</ul>
</li>
<li>commit前に異常終了した場合，ファイルの書き込みがなかったものとして扱う
<ul>
<li>ファイル実体の変更はないので，不整合は発生しない。</li>
</ul>
</li>
<li>非同期書き込みの際に停止した場合は
<ul>
<li>再実行すればいい</li>
</ul>
</li>
</ul>
<p><strong>ジャーナルファイルのモード</strong>：</p>
<ul>
<li>Orderedモード
<ul>
<li>データが，ファイル実体に反映された後で，そのデータを管理する<strong>inode情報</strong>，<strong>ディレクトリ情報</strong>のみをジャーナル領域に書き込む</li>
</ul>
</li>
<li>Writebackモード
<ul>
<li>データの保存領域への書き込み終了を待たずに，メタデータをジャーナル領域に書き込む</li>
<li>書き込み性能は向上するが，データの保存が失敗したっばいでもジャーナル領域が更新される可能性がある</li>
</ul>
</li>
<li>Journalモード
<ul>
<li>データの書き込み情報もジャーナル領域に書き込む</li>
<li>確実だが，遅い</li>
</ul>
</li>
</ul>
<p><strong>非同期入出力</strong>：プログラムが実行する入出力の終了を待たずに，次の命令を実行する方式であり，余計な待ち状態への意向をなくすことにより，システムのスループットを向上させる。</p>
<p>ディスクに関する仮想化：</p>
<ul>
<li>ディスクキャッシュ
<ul>
<li><strong>ディスク</strong>上のデータを一部主記憶に置くことで，低速なディスクへの読み書きを<strong>主記憶</strong>アクセス時間で実現する</li>
</ul>
</li>
<li>VFS
<ul>
<li>アプリケーションと二次記憶装置との間に位置する</li>
<li>アプリケーションからのファイル操作要求を，各二次記憶システムごとのAPIに変換</li>
</ul>
</li>
<li>ステージング
<ul>
<li><strong>テープ</strong>等のデータを一部<strong>ハードディスク</strong>に置くことで，低速な二次記憶への読み書きを（比較的高速な二次記憶である）<strong>ハードディスク</strong>へのアクセス時間で実現する。</li>
</ul>
</li>
</ul>
<hr>
<p>1.ファイルシステムの性能向上のために，ファイルを必要とする前に主記憶にあらかじめ読み込み，また書き込みを主記憶にのみ行う<strong>ディスクキャッシュ</strong>が用いられる。</p>
<p>2.入出力の完了を待たずに，入出力関数の終了を呼び出し側プログラムに返す入出力方式として，<strong>非同期入出力</strong>がある。この方式を用いることによりプログラム中で入出力処理と，他の仕事を多重化して実行することが可能となる。</p>
<p>3.様々な二次記憶に対して，統一したアクセス方式を提供するために，ファイルシステムを仮想化する方式が用いられることが多くなった。</p>
<p>(14-1)非同期入出力について以下の問いに答えなさい。<br>
(a)性能が上がる理由<br>
プログラムが実行する入出力命令の終了を待たずに，次の命令を実行するため，余計な待ち状態への移行をなくすことにより，システムのスループットを向上させることができる。</p>
<p>(b)プログラム側で注意する必要のある点<br>
プログラム中で読み込み(書き込み)を依頼した操作の終了を明示的に確認した後，読み込んだ(書き込んだ)データへの処理を行う必要があることに注意する必要がある。</p>
<p>(14-2)ジャーナルファイルのjournal modeにおいて、読み出しが他のモードより遅い理由を示しなさい。<br>
journalモードは，サイズの小さい管理情報だけでなく，書き込みデータもジャーナル領域に書き，さらにジャーナル領域から保存領域にも転送する必要があるため，データがファイル実体に反映された後にinode情報とディレクトリ情報のみを書き込むOrderedモードや，データの保存領域への書き込み終了を待たずにメタデータをジャーナル領域に書き込むWritebackモードよりも遅い。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：ファイルーファイル基礎]]></title>
        <id>https://zy080080.github.io/post/aj_P4T-me/</id>
        <link href="https://zy080080.github.io/post/aj_P4T-me/">
        </link>
        <updated>2021-01-19T02:17:46.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第13章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第13章　まとめ</p>
<!-- more -->
<hr>
<p>ファイルへのアクセス方式は大きく分けて，（順次アクセス）方式と（直接アクセス）方式がある。（順次アクセス）方式は主に（テープ型）デバイスで用いられ，（直接アクセス）方式は（ディスク型）デバイスで用いられる。<br>
　ファイルは，（テープ型）デバイスの場合，（レコード）と呼ばれる単位で読み書きが行われる。プログラム側からみた（レコード）を（論理レコード）と呼び，その（論理レコード）を複数集めて読み書きのオーバーヘッドを軽減した（物理レコード）と呼ばれる単位で，実際にはテープ型デバイスに格納される。<br>
　（ディスク型）デバイスは，（ボリューム）番号，（シリンダ）番号，（トラック）番号，（セクタ）番号を指定することにより，ディスクのどの位置でも読み書き可能であり，最少アクセス単位は（セクタ）単位となり，また，システムによっては複数の（セクタ）を集めた（クラスタ）と呼ばれる単位でのアクセスを行う場合もある。<br>
　ユーザにとって，自由でよりわかりやすい名前をつけることができるために開発されたファイルシステムが（階層化ディレクトリ）である。（階層化ディレクトリ）には，現在プログラムが注目しているディレクトリ上の位置を示す（カレントディレクトリ）と呼ばれる概念が存在し，（カレントディレクトリ）からみた注目ファイルの名前表現を（相対パス）表現と呼び。ルートを起点とする名前表現を（絶対パス）表現と呼ぶ。<br>
　直接アクセス方式では，複数のセクタの間の連結関係を情報として保持する必要がある。その方法に，（リスト）方式と，（インデックス）方式がある。（インデックス）方式は，FATファイルシステムなどで一般的に用いられている。性能向上のために，（インデックス）テーブルを（主記憶）内にあらかじめ読み込むことが行われる。</p>
<p>13.2)ディスクフラグメンテーションを２種類定義し、システム性能低下の定義（どのような性能低下か）と、解決方法についてについて、それぞれ説明しなさい</p>
<p>固定長割り当て時：ハードディスクにおいて，とびとびのセクターをアクセスするために，ヘッドのシーク時間及びトラック内の当該セクターへの移動時間による速度が低下する状態。<br>
性能低下の定義：とびとびのセクタをアクセスするためにヘッドの移動時間によってアクセス速度が低下する。<br>
解決方法：連続領域に再割り当てをする。</p>
<p>連続領域割り当て時：全体的にはハードディスクの容量は十分余っているのに，連続したセクターが割り当てられないことより，使えない細かな領域のみが残ってしまう状態。<br>
性能低下の定義：割り当てに適さない小さな領域が多く発生するほど，ディスクの利用効率が低下する。<br>
解決方法：主記憶領域割り当て時に可変長割り当てをする。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ーページ置き換え方式]]></title>
        <id>https://zy080080.github.io/post/XhbY1TXpf/</id>
        <link href="https://zy080080.github.io/post/XhbY1TXpf/">
        </link>
        <updated>2021-01-19T00:02:07.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第12章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第12章　まとめ</p>
<!-- more -->
<p>静的ページ置き換え方式</p>
<ul>
<li>LRU(Least Recently Used)</li>
<li>LFU(Least Frequently Used)</li>
<li>FIFO(First In First Out)</li>
</ul>
<p><strong>Beladyの例外</strong>：</p>
<ul>
<li>ページフレーム数を増やした時，ページフォルトが増加してしまう現象</li>
<li>原因
<ul>
<li>ページフレーム数により置き換えパターンが変化してしまうアルゴリズム　例）FIFO</li>
</ul>
</li>
</ul>
<p><strong>ワーキングセット方の近似</strong>：</p>
<ul>
<li>ワーキングセットの大きさ＝プロセスに割り当てるページ数
<ul>
<li>ワーキングセットを調べるのはコスト膨大</li>
<li>何らかの方法で近似</li>
</ul>
</li>
<li>ページフォルト発生の平均間隔
<ul>
<li>大きい場合（頻度小）
<ul>
<li>プロセスに与えられているページフレームは比較的十分</li>
</ul>
</li>
<li>小さい場合（頻度大）
<ul>
<li>プロセスには十分なページフレームが与えられていない</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ページフォルト平均間隔＋LRU</strong>：</p>
<ul>
<li>ワーキングセット方の近似とLRUの組み合わせ</li>
<li>プロセスに割り当てるページフレーム数を<strong>動的</strong>に変更</li>
<li>アルゴリズム
<ul>
<li>ページフォルトの平均間隔を計算</li>
<li>平均間隔がある値より小さい場合
<ul>
<li>プロセスに与えるページフレーム数を増やす</li>
</ul>
</li>
<li>平均間隔がある値より大きい場合
<ul>
<li>プロセスに与えるページフレーム数を減らす</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>1.ページ置き換え方式として，プロセスの生成時にプロセスに与えるページ数を決定する<strong>静的ページ置き換え方式</strong>と，プロセスの実行中にプロセスに与えるページ数が変化する<strong>動的ページ置き換え方式</strong>がある。</p>
<p>2.ページ置き換えアルゴリズムとして，<strong>最長不使用ページ置き換え（LRU）アルゴリズム</strong>，<strong>最低使用頻度順ページ置き換え（LFU）アルゴリズム</strong>，<strong>到着順ページ置き換え（FIFO）アルゴリズム</strong>などがある。</p>
<p>3.プロセスに与えるページ数を増やした結果，ページフォルト回数が増加してしまうBeladyの例外という現象がある。このような性質を持たないページ置き換えアルゴリズムを<strong>スタックアルゴリズム</strong>と呼ぶ。</p>
<p>4.動的ページ置き換えにおいて，プロセスに与えるページ数を決める手法として，プロセスが直近にアクセスしたページ集合（ワーキングセット）の大きさに応じて決定する<strong>ワーキングセット法</strong>がある。</p>
<p>5.ワーキングセットを下回るメモリ量しかプロセスが確保できない場合，常時ページフォルトが発生し，CPUの実効効率を低下させる<strong>スラッシング</strong>が発生する。</p>
<p>12.2)ワーキングセットを求めるのは事実上不能な理由を示すとともに、動的ページ置き換えにおけるページフォールト平均間隔＋LRU法について、ワーキングセットを求めずにどのように実現したかを中心に説明しなさい。<br>
ワーキングセットは常時に命令フェッチ、デコード、命令実効のサイクルで変わるため，求めるのは事実上不可能である。そこで，ワーキングセット法を近似するために，ページフォルト発生の平均間隔を計算し，この情報を静的置換えアルゴリズムに加えて，動的にプロセスに与えるページフレーム数を変えるのは，ページフォルト平均間隔+LRU法である。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ー仮想記憶]]></title>
        <id>https://zy080080.github.io/post/D3L-F6vjm/</id>
        <link href="https://zy080080.github.io/post/D3L-F6vjm/">
        </link>
        <updated>2021-01-18T16:06:45.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第11章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第11章　まとめ</p>
<!-- more -->
<p>仮想記憶</p>
<ul>
<li>大きさが無限の仮想アドレスを提供</li>
<li>ただし，スワップ操作に膨大な時間を要する</li>
</ul>
<p><strong>デマンドページング</strong>：</p>
<ul>
<li>ページフォルトが発生した時点</li>
<li>必要になった際に必要なページをスワップイン</li>
<li>スワップインの前にページフォルトが必ず発生</li>
<li><strong>ページフォルト処理にかかるコスト</strong>を削減したい</li>
</ul>
<p><strong>プリページング</strong>（予測ページング）</p>
<ul>
<li>必要になりそうなページを前もってスワップイン</li>
<li>予測が当たればページフォルトは発生せず<strong>コスト削減</strong></li>
</ul>
<p>デマンドプリフェッチ：</p>
<ul>
<li>ページフォルト割り込みが発生したタイミングで
<ul>
<li>ページフォルトを起こした対象ページは無論スワップイン</li>
<li><strong>将来必要と予想される数ページを同時に</strong>スワップイン</li>
</ul>
</li>
</ul>
<hr>
<p>1.仮想記憶の性能を向上させるためには，できる限りスワップ操作を行わないことが重要である。したがって，ページフォルト時にどのページをスワップアウトするかを決定するスワップスケジューリングは重要である。</p>
<p>2.スワップ操作は最小限にするべきであり，あらかじめ必要とされるページを事前にスワップインする方式として，<strong>デマンドプリフェッチ</strong>，<strong>初期ロードプリフェッチ</strong>などがある。</p>
<p>3.もっともアクセスされていないページをスワップアウトの対象とする<strong>LRUアルゴリズム</strong>は，今後アクセスされる確率のもっとも少ないページを近似的に選択可能なアルゴリズムである。しかし，このLEUアルゴリズムを正確に実装することも困難であり，経験的手法による近似的な実装が必要となる。</p>
<p>4.LRUアルゴリズムを近似的に実装するために，ページテーブル内に前回のページフォルト以降，当該ページの参照の有無を示す参照ビットを追加する。次のページフォルト時点で，参照頻度表を更新することにより，近似的，かつ少ない不可でLRUアルゴリズムを実装することが可能となる。</p>
<p>5.プログラムのアクセスする主記憶領域には，時間的および空間的局所性がある。さらに，プログラムが関数や手続きを高級言語で記述した場合は，関数や手続きの呼び出し時点で，急激にアクセスするページが変化する<strong>フェーズ現象</strong>が発生する。</p>
<p>(11-1)正確なLRUはなぜ実装困難なのかを、具体的な操作、および数字を示して説明しなさい。<br>
LRUを実現するには，ページテーブルに，各ページのアクセス時刻を記録する項目を追加する必要がある。具体的には，主記憶アクセスごとに時刻を調べてアクセス時刻を更新し，ページフォルト時にページテーブルを走査して，最もアクセス時刻の古い項目を探す必要がある。<br>
しかし，主記憶アクセスは10の-9乗秒程度の速度を要求され，時刻を更新するのに10の-9乗秒でできないため，LRUは実装困難である。</p>
<p>(11-2)高級言語によるプログラムの主記憶アクセスパターンのフェーズ化が、どのような時点で、なぜ起こるかを、２つ事例を示して、説明しなさい。<br>
フェーズ化は，プログラムがアクセスするページは主記憶上隣接した領域を連続してアクセスする時，及びある時刻を境にプログラムがアクセスするページが急に切り替わる時に起こる。<br>
事例：1.ループを抜けた時。2.実行する関数が変わった時。<br>
その理由は，プログラムが頻繁にアクセスするページ，またはその近くのアドレスに再びアクセスしなくなるからである。</p>
<p>(11-3)スワップインすべき場所の選択に意味がないことを示しなさい。<br>
ページシステムの特徴に，ページテーブルを介して，ページとページフレームをマッピンッグすることによるページフレームの動的再配置機能がある。よって，スワップイン操作により，該当ページが主記憶上のどのページフレームに読み込まれてもシステムの性能やプロフラム側が発行するアドレスに全く影響しない。<br>
　通常のメモリアクセスは10<sup>(-9)秒程度の速度を要求されるが，スワップ操作時は10</sup>(-1)秒程度の時間を要求されるだけである。したがった，スワップ操作時にさらに10<sup>(-3)〜10</sup>(-2)秒程度の追加の処理を挿入しても，ほとんどシステム全体の性能に影響することはない。</p>
<p>ページングによるメモリ管理は，アドレスの上位を（ページ番号），下位を（オフセット）に分けて管理する方式である。（ページ番号）は（ページテーブル）内の位置を示し，示された（ページテーブル）のエントリーには各種フラグと（ページフレーム番号）を示すポインタが格納されている。仮想記憶におけるページ置き換えをページフォルト時に行う方式を（デマンドページング）と呼ぶ。さらに，ページフォルトが起こった時に，そのページだけではなく，将来必要となるページも呼び込む方式が（<strong>デマンドプリフェッチ</strong>）である。理想的なページ置き換えは，次にアクセスされる確率のもっとも（低い）ページを置き換え（スワップアウトする）方法である。この近似解として（LRU）がある。しかし，（LRU）も正確に実装することが困難なので，さらに近似が必要となる。<br>
　プログラムが使用するページの集合は，プログラムの実行にしたがって急激に変化することが多い，これを（フェーズ化）現象と呼び，一般に関数などにより，プログラムを（<strong>構造化</strong>）した場合に顕著となる</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ーセグメンテーション，ページかセグメンテーション]]></title>
        <id>https://zy080080.github.io/post/zAjTn6PkI/</id>
        <link href="https://zy080080.github.io/post/zAjTn6PkI/">
        </link>
        <updated>2021-01-18T11:35:35.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第10章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第10章　まとめ</p>
<!-- more -->
<p><strong>多重レベルページング</strong>：</p>
<ul>
<li>従来のページングにおける，仮想アドレスの「ページ番号部」を複数に分割</li>
<li>それぞれをページ番号として階層化したテーブルを検索</li>
<li>必要なテーブルのみを主記憶上に置くことで，主記憶使用量を削減（残りは仮想記憶へ）</li>
<li>ただし，多段化により，主記憶アクセスは増加 =&gt;TLBにより解決</li>
</ul>
<p><strong>0レベルページング（連想写像方式）</strong>：</p>
<ul>
<li>一般的なページング
<ul>
<li>主記憶上にページテーブル</li>
<li>CPU内のMMUが，ページテーブルを用いてアドレス変換</li>
</ul>
</li>
<li>0レベルページング
<ul>
<li>ハードウェアとしてのMMUを持たない</li>
<li>一般的なページテーブルを持たず，連想メモリで構成したTLBでアドレス変換</li>
</ul>
</li>
<li>メリット
<ul>
<li><strong>高クロック</strong>実装が可能
<ul>
<li>MMU不要のため，CPU機構が単純化</li>
</ul>
</li>
</ul>
</li>
<li>デメリット
<ul>
<li>TLBヒットしなかった場合のオーバーヘッドが膨大
<ul>
<li>ソフトウェア処理のため</li>
</ul>
</li>
</ul>
</li>
<li>よって
<ul>
<li>主記憶使用量の少ないプログラムには<strong>高速</strong></li>
<li>主記憶使用量の多いプログラムには<strong>非常に低速</strong></li>
</ul>
</li>
</ul>
<p><strong>セグメンテーション</strong>：</p>
<p>ページングの上，プログラム部，データ部，スタック部などの分離とプロセス間で共有を実現する。</p>
<ul>
<li>ページ（ページング）
<ul>
<li>一定の大きさを割り当て単位とする</li>
</ul>
</li>
<li>セグメント（セグメンテーション）
<ul>
<li>プロセスに対し<strong>複数</strong>のセグメントを割り当て
<ul>
<li>各セグメントは論理的に<strong>独立</strong></li>
<li>プログラム部，データ部など固有領域として使用可能</li>
</ul>
</li>
<li>各セグメントはその論理区間の大きさを自由に<strong>増減可能</strong></li>
</ul>
</li>
<li>利点
<ul>
<li>プログラム部，データ部など，用途別に複数をプロセスに割り当て</li>
<li>各セグメンテーションは大きさを増減可能</li>
</ul>
</li>
<li>欠点
<ul>
<li>フラグメンテーション</li>
</ul>
</li>
</ul>
<p><strong>ページ化セグメンテーション</strong>：</p>
<ul>
<li>セグメンテーションを複数のページにより構成する。</li>
<li>セグメントごとにページテーブルを用意</li>
<li>利点：
<ul>
<li>フラグメンテーションの回避
<ul>
<li>主記憶割り当ては基本的にページ単位</li>
</ul>
</li>
<li>複数セグメント
<ul>
<li>各セグメントは大きさ増減可能</li>
<li>複数使用により，用途別に使い分け可能</li>
</ul>
</li>
<li>プロセス間共有
<ul>
<li>セグメンテーションとほぼ同様に共有可能<br>
　- ページテーブルの分散</li>
<li>ページテーブルが複数に分割されるので，多重レベルページング同様，その一部を<strong>仮想記憶に追い出すことで主記憶使用量削減</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ポイント">ポイント</h2>
<p>1.高級言語では，プログラム領域，データ領域，スタック領域，動的データ領域など複数のアドレス空間を用いる。<strong>セグメンテーション</strong>を用いることにより，プログラムに対して複数の異なるアドレス空間を提供することが可能である。さらに，複数のプロセス間で仮想アドレス空間を共有する共有メモリも容易に実現可能である。</p>
<p>2.<strong>ページカセングメンテーション</strong>は，ページングとセグメンテーションの両方の利点を有する方式であり，現在の主記憶管理手法の主流である。</p>
<p>3.ページングシステムでは，ページテーブルの大きさが大きくなり，主記憶領域を圧迫する。しかし，<strong>ページかセグメンテーション</strong>や<strong>多重レベルページング</strong>などでは，ページテーブルも仮想記憶内で管理するため，解決可能である。</p>
<p>4.最小限のハードウェアで高性能を得るために開発され，MIPS社のR2000で採用された0レベルページングは，ページテーブルの管理を，ハードウェアで実装されたMMUではなく，ソフトウェア割り込みで実装した。</p>
<p>10.1　多重レベルページングと仮想記憶を用いることにより，主記憶内に存在するページテーブルの大きさが無視できることを示せ。<br>
　多重レベルページングを用いることにより，各プロセスが必要とするページテーブル自体も仮想記憶の対象となる。つまり，全てのページテーブルのうち，直近にアクセスされたページテーブルの一部のみが主記憶に存在することになる。したがって，プロセスが現時点で必要としているページテーブル部分のみが主記憶に配置される。</p>
<p>10.2　ページ化セグメンテーションにおいて，外部・内部フラグメンテーションの問題について説明せよ。<br>
　ページ化セグメンテーションは主記憶の割り当てはページ単位の固定長割り当てなので，外部セグメンテーションは存在しない。しかし，プロセスには主記憶をページ単位で割り当てるため，例えばページサイズが8kBの場合，複数割り当てたページ群の最後のページで平均4KBの未使用領域（内部フラグメンテーション）が発生する。しかし，現在のプロセスに必要な主記憶量に比べると無視できる量である。</p>
]]></content>
    </entry>
</feed>