<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzy-tech.github.io/</id>
    <title>听故事的人</title>
    <updated>2022-07-29T02:54:57.168Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzy-tech.github.io/"/>
    <link rel="self" href="https://zzy-tech.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zzy-tech.github.io/images/avatar.png</logo>
    <icon>https://zzy-tech.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[[repro] Overcoming type erasure in Scala]]></title>
        <id>https://zzy-tech.github.io/post/vJovTPsib/</id>
        <link href="https://zzy-tech.github.io/post/vJovTPsib/">
        </link>
        <updated>2022-07-29T04:32:01.000Z</updated>
        <content type="html"><![CDATA[<p><strong>source: <a href="https://medium.com/@sinisalouc/overcoming-type-erasure-in-scala-8f2422070d20">https://medium.com/@sinisalouc/overcoming-type-erasure-in-scala-8f2422070d20</a></strong></p>
<p>This article aims to show a couple of techniques to tackle some common problems caused by type erasure in Scala.</p>
<h2 id="introduction">Introduction</h2>
<p>Scala has a really strong type system. Existential types, structural types, nested types, path-dependant types, abstract and concrete type members, type bounds (upper, lower, view, context), use-site and declaration-site type variance, support for type polymorphism (subtype, parametric, F-bounded, ad-hoc), higher-kinded types, generalized type constraints… And the list goes on.</p>
<p>But even though Scala’s type system is theoretically very strong, in practice some type-related features are weakened by the restrictions and limitations of its runtime environment — that’s right, I’m looking at you, <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">type erasure</a>.</p>
<p>What is type erasure? Well, simply put, it’s a procedure performed by Java and Scala compilers which removes all generic type information after compilation. This means that we are not able to differentiate between, say, List[Int] and List[String] at runtime. Why does the compiler do this? Well, because Java Virtual Machine (the underlying runtime environment that runs both Java and Scala) doesn’t know anything about generics.</p>
<p>What happens is that type parameters in a generic class get replaced either with Object or its upper bound. For example:</p>
<pre><code>class Foo[T] {
    val foo: T
}

class Bar[T &lt;: Something] {
    val bar: Something
}
</code></pre>
<p>becomes</p>
<pre><code>class Foo {
    val foo: Object
}

class Bar {
    val bar: Something
}
</code></pre>
<p>So you see, runtime has no idea about the actual class that a generic class was parameterized with. In our example, it only sees raw Foo and Bar.</p>
<p>Don’t think that type erasure is a product of someone’s incompetence or ignorance or whatever. It’s not bad design (which would suggest it was a product of someone not being smart enough or competent enough); it’s a deliberate trade-off. Not only did it help with <a href="https://blogs.oracle.com/darcy/entry/kinds_of_compatibility">source, binary and behavioral compatibility</a> in the earlier Java days, but it also helps with some advanced type system mechanisms, such as <a href="https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html">higher-kinded types</a> (thanks Gabriel Claramunt for pointing this out).</p>
<p>Now let’s see what are some handy ways that we can handle the downsides of type erasure in Scala.</p>
<h2 id="how-it-works-or-doesnt-work">How it works (or doesn’t work)</h2>
<p>Here’s one simple example of type erasure:</p>
<pre><code>object Extractor {
    def extract[T](list: List[Any]) = list.flatMap {
        case element: T =&gt; Some(element)
        case _ =&gt; None
    }
}

val list = List(1, &quot;string1&quot;, List(), &quot;string2&quot;)
val result = Extractor.extract[String](list)
println(result) // List(1, string1, List(), string2)
</code></pre>
<p>Method extract() takes a list of all kinds of objects; since it holds objects of type Any, we can put numbers, booleans, strings, bananas, oranges, whatever. By the way, seeing List[Any] in a piece of code should be an instant “code smell”, but let’s forget about best practices for a second and focus on the problem with type erasure.</p>
<p>So, our desire is to have a method that takes a list of mixed objects and extracts only objects of certain type. We can choose this type by parameterizing the method extract() with it. In the given example the chosen type is String, which means that we will try to extract all strings from a given list.</p>
<p>From a strictly language point of view (without going into runtime details), this code is reasonable. We know that pattern matching is able to figure out the type of a given object without problems by deconstructing it. However, due to program being executed on JVM, all generic types are erased after compilation. Therefore pattern matching cannot really get far; everything beyond the “first level” of type is erased. Matching our variable directly on Int or String (or any non-generic type, such as MyNonGenericClass) would work fine, but matching it on T, where T is a generic parameter, cannot work. Compiler will give us a warning saying “abstract type pattern T is unchecked since it is eliminated by erasure”.</p>
<p>To provide some assistance with these situations, Scala introduced Manifests somewhere around version 2.7. However, they had problems with not being able to represent certain types so Scala 2.10. deprecated them in favour of the more powerful <a href="http://docs.scala-lang.org/overviews/reflection/typetags-manifests.html">TypeTags</a>.</p>
<p>Type tags are divided into three separate types:</p>
<ul>
<li>TypeTag</li>
<li>ClassTag</li>
<li>WeakTypeTag</li>
</ul>
<p>Even though this is the official classification from the documentation, better division in my opinion would be something like:</p>
<ul>
<li>TypeTag:
<ul>
<li>“classic”</li>
<li>WeakTypeTag</li>
</ul>
</li>
<li>ClassTag</li>
</ul>
<p>I’m trying to make a point that TypeTag and WeakTypeTag are actually two flavours of the same thing with only one significant difference (as we’ll show later), while ClassTag is a quite different construct.</p>
<h2 id="classtag">ClassTag</h2>
<p>Let’s get back to our extractor example and see how we can fix the type erasure problem. All we’re going to do now is add a single implicit parameter to the extract() method:</p>
<pre><code>import scala.reflect.ClassTag
object Extractor {
    def extract[T](list: List[Any])(implicit tag: ClassTag[T]) = list.flatMap {
        case element: T =&gt; Some(element)
        case _ =&gt; None
    }
}

val list: List[Any] = List(1, &quot;string1&quot;, List(), &quot;string2&quot;)
val result = Extractor.extract[String](list)
println(result) // List(string1, string2)
</code></pre>
<p>And voila! Suddenly the print statement displays “List(string1, string2)”. In your face, type erasure. Note that we can also use context bound syntax here:</p>
<pre><code>// def extract[T](list: List[Any])(implicit tag: ClassTag[T]) =
def extract[T : ClassTag](list: List[Any]) =
</code></pre>
<p>I will use the standard syntax simply to make the code as clear as possible, without any extra syntax sugar.</p>
<p>So, how does it work? Well, the thing is that when we require an implicit value that is of type ClassTag, compiler will create this value for us. <a href="http://lampwww.epfl.ch/~hmiller/scaladoc/library/scala/reflect/ClassTag.html">Documentation</a> says:</p>
<blockquote>
<p>If an implicit value of type u.ClassTag[T] is required, the compiler will make one up on demand.</p>
</blockquote>
<p>So, the compiler is happy to provide us with an implicit instance of a needed ClassTag, we just need to ask. This mechanism will also be used with TypeTag and WeakTypeTag.</p>
<p>OK, we have our implicit ClassTag value available in extract() method (thanks, compiler). What happens once we’re inside the method body? Look at the example once again — not only did the compiler automatically provide us with the value for our implicit parameter tag, which is nice enough, but we <strong>never needed to use the parameter itself</strong>. We never had to do anything with the “tag” value. It’s the mere existence of it that allowed our pattern matching to successfully match the String elements in our list. OK, that’s pretty nice of the compiler, but it feels like there’s too much “magical stuff” going on. Let’s see that in more detail.</p>
<p>We can check the <a href="http://The%20compiler%20tries%20to%20turn%20unchecked%20type%20tests%20in%20pattern%20matches%20into%20checked%20ones%20by%20wrapping%20a%20%28_:%20T%29%20type%20pattern%20as%20ct%28_:%20T%29,%20where%20ct%20is%20the%20ClassTag%5BT%5D%20instance.">docs</a> in search for an explanation. Indeed, it’s hidden here:</p>
<blockquote>
<p>Compiler tries to turn unchecked type tests in pattern matches into checked ones by wrapping a (<em>: T) type pattern as ct(</em>: T), where ct is the ClassTag[T] instance.</p>
</blockquote>
<p>Basically what happens is that if we provide the compiler with an implicit ClassTag, it will rewrite the condition(s) in pattern matching to use the given tag as an extractor. Our condition:</p>
<pre><code>case element: T =&gt; Some(element)
</code></pre>
<p>gets translated by the compiler (if there is an implicit tag in scope) into this:</p>
<pre><code>case (element @ tag(_: T)) =&gt; Some(element)
</code></pre>
<p>In case you never saw the “@” construct before, it’s just a way of giving a name to the class you’re matching, for example:</p>
<pre><code>case Foo(p, q) =&gt; // we can only reference parameters via p and q
case f @ Foo(p, q) =&gt; // we can reference the whole object via f
</code></pre>
<p>If there is no available implicit ClassTag for type T to be used, compiler will be crippled (due to lack of type information) and it will issue a warning that our pattern matching will suffer from type erasure on type T. Compilation won’t break, but don’t expect compiler to know what T is when we get to pattern matching (since it will be erased by the JVM at runtime). If we do provide an implicit ClassTag for type T, compiler will be happy to provide a proper ClassTag at compile-time as we have seen in our example. The tag will bring along the information about T being a String and type erasure cannot touch it.</p>
<p>Looks good, doesn’t it? But there’s one important weakness. If we wanted to differentiate our types on a higher level and get values of List[Int] from our initial list while ignoring e.g. List[String], we would not be able to do so:</p>
<pre><code>val list: List[List[Any]] = List(List(1, 2), List(&quot;a&quot;, &quot;b&quot;))
val result = Extractor.extract[List[Int]](list)
println(result) // List(List(1, 2), List(a, b))
</code></pre>
<p>Whoops! We wanted to extract only List[Int], but we got a List[String] too. Class tags <strong>cannot differentiate on a higher level</strong>. Only on the first one. This means that our extractor can differentiate between e.g. sets and lists, but it cannot tell apart one list from another (e.g. List[Int] vs List[String]). Of course, it’s not just the lists — this goes for all generic traits/classes.</p>
<h2 id="typetag">TypeTag</h2>
<p>Where ClassTag fails, TypeTag succeeds gloriously. It can differentiate a List[String] from a List[Integer]. It can go deeper too, such as differentiating List[Set[Int]] from List[Set[String]. This is possible because TypeTag has richer information about the generic type at run time. We can easily get the full path of the type in question, as well as all the nested types (if there are any). To get this information, you just need to invoke tpe() on a given tag.</p>
<p>Here’s an example. The implicit tag parameter is provided by the compiler, just like with ClassTag. Pay attention to the “args” argument — it’s the one that contains additional type information which ClassTag doesn’t have (information about List being parameterized by Int).</p>
<pre><code>import scala.reflect.runtime.universe._
object Recognizer {
    def recognize[T](x: T)(implicit tag: TypeTag[T]): String =
        tag.tpe match {
            case TypeRef(utype, usymbol, args) =&gt;
                List(utype, usymbol, args).mkString(&quot;\n&quot;)
        }
}

val list: List[Int] = List(1, 2)
val result = Recognizer.recognize(list)
println(result)
// prints:
//   scala.type
//   type List
//   List(Int)
</code></pre>
<p>(You may need to add a <a href="http://mvnrepository.com/artifact/org.scala-lang/scala-reflect">dependency</a>).</p>
<p>I introduced a new object here — a Recognizer. What happened to the good-old Extractor? Well, sad news. We cannot implement an Extractor using TypeTags. Good thing about them is having more information about the type, such as knowing about the higher types (that is, being able to differentiate List[X] from List[Y]), but their downside is that they <strong>cannot be used on objects at runtime</strong>. We can use the TypeTag to get information about a certain type at runtime, but we cannot use it to find out the type of some object at runtime. Do you see the difference? What we passed to recognize() was a straightforward List[Int]; it was the declared type of our List(1,2) value. But if we declared our List(1, 2) as a List[Any], TypeTag would tell us that we passed a List[Any] to it.</p>
<p>OK, here are the two main differences between ClassTags and TypeTags in one place:</p>
<ol>
<li>
<p>ClassTag doesn’t know about “higher type”; given a List[T], a ClassTag only knows that the value is a List and knows nothing about T.</p>
</li>
<li>
<p>TypeTag knows about “higher type” and has a much richer type information, but cannot be used for getting type information about values at runtime. In other words, TypeTag provides runtime information about the type while ClassTag provides runtime information about the value (more specifically, information that tells us what is the actual type of the value in question at runtime).</p>
</li>
</ol>
<p>There’s one more thing worth mentioning regarding the difference between ClassTag and (Weak)TypeTag: ClassTag is a classical good old type class. It comes bundled with a separate implementation for each type, which makes it a standard <a href="https://medium.com/@sinisalouc/ad-hoc-polymorphism-and-type-classes-442ae22e5342#.41sf94ijq">type class pattern</a>. On the other hand, (Weak)TypeTag is a bit more sophisticated and to use it we need to have a special import in our code, as you may have noticed in the snippet given earlier. We need to import the <a href="http://www.scala-lang.org/api/current/scala-reflect/index.html#scala.reflect.api.Universe@WeakTypeTag%5BT%5DextendsEqualswithSerializable">universe</a>:</p>
<blockquote>
<p>Universe provides a complete set of reflection operations which make it possible for one to reflectively inspect Scala type relations, such as membership or subtyping.</p>
</blockquote>
<p>Don’t worry, all you need to do is to simply import the correct universe, and in case of (Weak)TypeTag that is scala.reflect.runtime.universe._ (<a href="http://www.scala-lang.org/api/current/scala-reflect/index.html#scala.reflect.runtime.package">docs</a>).</p>
<h2 id="weaktypetag">WeakTypeTag</h2>
<p>You are probably under the impression that TypeTag and WeakTypeTag are quite similar as all the differences so far were explained in respect to the ClassTag. And that is correct; they are indeed two variants of the same tool. But, there is an important difference.</p>
<p>We saw that TypeTag is smart enough to examine a type as well as its type parameters, then their type parameters etc. However, all those types were concrete. If a type is abstract, TypeTag will not be able to resolve it. This is where WeakTypeTag comes into play. Let’s revise the TypeTag example for a second:</p>
<pre><code>val list: List[Int] = List(1, 2)
val result = Recognizer.recognize(list)
</code></pre>
<p>See that Int over there? It could have been any other concrete type, such as String, Set[Double] or MyCustomClass. But if you have an abstract type, you need a WeakTypeTag.</p>
<p>Here’s an example. Note that we need a reference to an abstract type so we will simply wrap everything in an abstract class.</p>
<pre><code>import scala.reflect.runtime.universe._
abstract class SomeClass[T] {

    object Recognizer {
        def recognize[T](x: T)(implicit tag: WeakTypeTag[T]): String =
            tag.tpe match {
                case TypeRef(utype, usymbol, args) =&gt;
                    List(utype, usymbol, args).mkString(&quot;\n&quot;)
            }
    }

    val list: List[T]
    val result = Recognizer.recognize(list)
    println(result)
}

new SomeClass[Int] { val list = List(1) }
// prints:
//   scala.type
//   type List
//   List(T)
</code></pre>
<p>Resulting type is a List[T]. If we had used a TypeTag instead of a WeakTypeTag, compiler would have complained that there is “<em>no TypeTag available for List[T]</em>”. So, you can look at WeakTypeTag as a sort of a superset of the TypeTag.</p>
<p>Note that WeakTypeTag tries to be as concrete as possible, so if there is a type tag available for some abstract type, WeakTypeTag will use that type tag and thus make the type concrete instead of leaving it abstract.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Before we finish, let me mention that each type tag can also be instantiated explicitly using available helpers:</p>
<pre><code>import scala.reflect.classTag
import scala.reflect.runtime.universe._

val ct = classTag[String]
val tt = typeTag[List[Int]]
val wtt = weakTypeTag[List[Int]]

val array = ct.newArray(3)
array.update(2, &quot;Third&quot;)

println(array.mkString(&quot;,&quot;))
println(tt.tpe)
println(wtt.equals(tt))

//  prints:
//    null,null,Third
//    List[Int]
//    true
</code></pre>
<p>That’s all. We saw three constructs, ClassTag, TypeTag and WeakTypeTag, that will get you through most of your type erasure troubles in your everyday Scala life. Note that using tags (which is basically <a href="http://docs.scala-lang.org/overviews/reflection/overview.html">reflection</a> under the hood) can slow things down and make the generated code significantly bigger, so don’t go around adding implicit type tags all over your library to make the compiler smarter “just in case” and for no practical reason. Save them for when you really need them. And when you do need them, they will provide a powerful weapon against JVM’s type erasure.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go学习笔记]]></title>
        <id>https://zzy-tech.github.io/post/wVjJ9Td2t/</id>
        <link href="https://zzy-tech.github.io/post/wVjJ9Td2t/">
        </link>
        <updated>2022-05-06T15:30:11.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Structs are mutable.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About slice]]></title>
        <id>https://zzy-tech.github.io/post/FCxr0jmyz/</id>
        <link href="https://zzy-tech.github.io/post/FCxr0jmyz/">
        </link>
        <updated>2022-05-03T09:36:10.000Z</updated>
        <summary type="html"><![CDATA[<p>In the early development of Go, it took about a year to decide the answers to these questions before the design felt right. The key step was the introduction of slices, which built on fixed-size arrays to give a flexible, extensible data structure. To this day, however, programmers new to Go often stumble over the way slices work, perhaps because experience from other languages has colored their thinking.</p>
]]></summary>
        <content type="html"><![CDATA[<p>In the early development of Go, it took about a year to decide the answers to these questions before the design felt right. The key step was the introduction of slices, which built on fixed-size arrays to give a flexible, extensible data structure. To this day, however, programmers new to Go often stumble over the way slices work, perhaps because experience from other languages has colored their thinking.</p>
<!-- more -->
<p>Resource: https://go.dev/blog/slices</p>
<h2 id="the-slice-header">The slice header</h2>
<p>It’s not quite the full story, but for now think of a slice as a little data structure with two elements: a length and a pointer to an element of an array. You can think of it as being built like this behind the scenes:</p>
<pre><code>type sliceHeader struct {
    Length        int
    ZerothElement *byte
}

slice := sliceHeader{
    Length:        50,
    ZerothElement: &amp;buffer[100],
}
</code></pre>
<h2 id="passing-slice-to-functions">Passing slice to functions</h2>
<p>It’s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.</p>
<pre><code>slashPos := bytes.IndexRune(slice, '/')
</code></pre>
<p>When we called IndexRune in the previous example, it was passed a copy of the slice header. That behavior has important ramifications.</p>
<p><strong>Note</strong>: Even though the slice header is passed by value, the header includes a <strong>pointer to elements of an array</strong>, so both the original slice header and the copy of the header passed to the function describe the same array. Therefore, when the function returns, the modified elements can be seen through the original slice variable.</p>
<h2 id="capacity">Capacity</h2>
<p>Besides the array pointer and length, the slice header also stores its capacity:</p>
<pre><code>type sliceHeader struct {
    Length        int
    Capacity      int
    ZerothElement *byte
}
</code></pre>
<p>The Capacity field records how much space the underlying array actually has; it is the maximum value the Length can reach. Trying to grow the slice beyond its capacity will step beyond the limits of the array and will trigger a panic.</p>
<h2 id="nil">Nil</h2>
<p>As an aside, with our newfound knowledge we can see what the representation of a nil slice is. Naturally, it is the zero value of the slice header:</p>
<pre><code>sliceHeader{
    Length:        0,
    Capacity:      0,
    ZerothElement: nil,
}
</code></pre>
<p>An empty slice can grow (assuming it has non-zero capacity), but a nil slice has no array to put values in and can never grow to hold even one element.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is sequence?]]></title>
        <id>https://zzy-tech.github.io/post/FS9Dkp9hu/</id>
        <link href="https://zzy-tech.github.io/post/FS9Dkp9hu/">
        </link>
        <updated>2022-05-02T13:39:22.000Z</updated>
        <summary type="html"><![CDATA[<p>from http://support.kodable.com/en/articles/417330-what-is-sequence</p>
<p><strong>Definition</strong>:</p>
<p>Sequence, the order that commands are executed by a computer, allows us to carry out tasks that have multiple steps.</p>
]]></summary>
        <content type="html"><![CDATA[<p>from http://support.kodable.com/en/articles/417330-what-is-sequence</p>
<p><strong>Definition</strong>:</p>
<p>Sequence, the order that commands are executed by a computer, allows us to carry out tasks that have multiple steps.</p>
<!-- more -->
<p>In programming, sequence is a basic algorithm: A set of logical steps carried out in order. Computers need instructions in the form of an algorithm in order to complete a desired task, and this algorithm must have the correct order of strps, or sequence.</p>
<p><strong>Why is Sequence Important?</strong> In both programming and day to day tasks, if we don't put every step in the right sequence, the end result isn't what we wanted. Sequence is the most foundational concept in programming, and everything we learn moving forward will build on this concept.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[モジュールが持つ特性]]></title>
        <id>https://zzy-tech.github.io/post/ChAMKuYiO/</id>
        <link href="https://zzy-tech.github.io/post/ChAMKuYiO/">
        </link>
        <updated>2021-05-20T12:58:16.000Z</updated>
        <summary type="html"><![CDATA[<p>モジュール凝集度およびモジュール結合度</p>
]]></summary>
        <content type="html"><![CDATA[<p>モジュール凝集度およびモジュール結合度</p>
<!-- more -->
<h2 id="モジュール凝集度">モジュール凝集度</h2>
<p>モジュールの凝集度は高いものほどよく，情報的もしくは機能的凝集を目標とする。</p>
<h3 id="暗号的-coincidental-cohesion-低">暗号的 Coincidental Cohesion （低）</h3>
<ul>
<li>複数の，無関係な機能をモジュール化したもの</li>
<li>大きさだけで分割，偶然一致している部分を共通モジュール化</li>
</ul>
<h3 id="論理的-logical-cohesion">論理的 Logical Cohesion</h3>
<ul>
<li>複数の機能を一つのモジュールにし，動かすものを外部から指示する形</li>
<li>論理が似ている/呼称が同じだけでモジュール化</li>
</ul>
<h3 id="時間的-classical-cohesion">時間的 Classical Cohesion</h3>
<ul>
<li>複数の実行時間が同じ逐次的な機能を一つのモジュールにまとめたもの</li>
<li>処理タイミングが同じだけでモジュール化</li>
</ul>
<h3 id="手順的-procedural-cohesion">手順的 Procedural Cohesion</h3>
<ul>
<li>複数の関連性を持つ逐次的な機能を一つのモジュールにまとめたもの</li>
<li>コントロールの流れのまとまったひとかたまりをモジュール化</li>
</ul>
<h3 id="連絡的-communicational-cohesion">連絡的 Communicational Cohesion</h3>
<ul>
<li>モジュール内の要素間でデータの受け渡しを行うもの</li>
<li>コントロールの流れ＋扱うデータの流れを考慮してモジュール化</li>
</ul>
<h3 id="情報的-informational-cohesion">情報的 Informational Cohesion</h3>
<ul>
<li>特定のデータ構造を持つ複数の機能をまとめたもの</li>
<li>特定のデータ構造を扱う複数機能をモジュール化</li>
</ul>
<h3 id="機能的-functional-cohesion-高">機能的 Functional Cohesion （高）</h3>
<ul>
<li>全ての要素が一つの機能を実行するために関連しあっているもの</li>
</ul>
<h2 id="モジュールの結合度">モジュールの結合度</h2>
<p>モジュールの結合度は低いものほど良く，スタンプ結合もしくは，データ結合を目標とする。</p>
<h3 id="内容結合">内容結合</h3>
<ul>
<li>他のモジュール内のデータを直接参照したり，直接ブランチしたりする</li>
<li>相手の内容の参照，修正，使用</li>
</ul>
<h3 id="共通結合">共通結合</h3>
<ul>
<li>共通域のデータ構造を参照する</li>
<li>共通データ構造の複数モジュールでの使用</li>
</ul>
<h3 id="外部結合">外部結合</h3>
<ul>
<li>外部宣言しているデータを参照する</li>
<li>共通データを複数モジュールで参照</li>
</ul>
<h3 id="制御結合">制御結合</h3>
<ul>
<li>制御要素がパラメータとして渡される</li>
<li>相手に渡すパラメータで，相手の処理を変更</li>
</ul>
<h3 id="スタンプ結合">スタンプ結合</h3>
<ul>
<li>二つ以上のモジュールが，共通域にはない同じデータを共有する</li>
<li>共通データ構造の複数モジュールに置ける使用であるが，その構造定義はモジュール側に持つ（パラメータで参照）</li>
</ul>
<h3 id="データ結合">データ結合</h3>
<ul>
<li>データ要素のパラメータ受け渡しでインターフェースを取る</li>
<li>モジュール間の関係は，必要なデータのみの受け渡しその値によって相手は影響を受けない</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ソフトウェア工学]]></title>
        <id>https://zzy-tech.github.io/post/1KjJfbkSn/</id>
        <link href="https://zzy-tech.github.io/post/1KjJfbkSn/">
        </link>
        <updated>2021-04-23T17:19:49.000Z</updated>
        <summary type="html"><![CDATA[<p>ソフトウェア工学の概要，システム開発のプロジェクト</p>
]]></summary>
        <content type="html"><![CDATA[<p>ソフトウェア工学の概要，システム開発のプロジェクト</p>
<!-- more -->
<h2 id="第一回">第一回</h2>
<h3 id="概要">概要</h3>
<h4 id="ソフトウェアとは">ソフトウェアとは</h4>
<p>定義：情報処理システムのプログラム，手続き，規則および関連文書の全体または一部分。</p>
<h4 id="ソフトウェアの種類">ソフトウェアの種類</h4>
<ul>
<li>市販ソフトウェア：同一製品
<ul>
<li>パッケージソフト
<ul>
<li>DVDなどの媒体を購入</li>
</ul>
</li>
<li>アプリ
<ul>
<li>アプリストアからダウンロード</li>
</ul>
</li>
<li>クラウドサービス
<ul>
<li>ブラウザなどからアクセス</li>
</ul>
</li>
</ul>
</li>
<li>カスタムソフトウェア：個別製品
<ul>
<li>受託開発，企業システムに利用。</li>
</ul>
</li>
</ul>
<h4 id="システムの例">システムの例</h4>
<p>予約・発券システム，搭乗員シフト管理システム，経営管理システム，採点システムなど。</p>
<h3 id="ソフトウェア工学とシステム開発">ソフトウェア工学とシステム開発</h3>
<h4 id="ソフトウェア工学とは">ソフトウェア工学とは</h4>
<p>ソフトウェアが大規模化，複雑化し，<br>
ソフトウェア開発に工学的な方法を取り入れる取り組み。</p>
<h4 id="ソフトウェア工学">ソフトウェア「工学」</h4>
<ul>
<li>工学であるかどうかは議論の的
<ul>
<li>経験則の集まり，ノウハウのかたまり
<ul>
<li>工学：数式による実世界のモデル化（物理）</li>
<li>ソフトウェア工学：プロジェクト管理による効率的なシステム開発</li>
</ul>
</li>
<li>Wikipediaより
<ul>
<li>もともと，プログラミングおよびシステム分析と呼ばれていた活動などを総称的にsoftware engineeringと呼ぶ。</li>
<li>プログラミングに必要とされる理論的側面をコンピュータ科学と呼び，そうでないあらゆる面をsoftware engineeringと称する。</li>
<li>「プログラミング」を単なる技巧や技能ではなく工学として扱うことを主張する用語であり，そのような指針を文書化したもので使われる。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="工学を導入する理由">工学を導入する理由</h4>
<ul>
<li>ソフトウェアの発注はビジネス契約である
<ul>
<li>コスト，品質，納期が守られる必要がある</li>
</ul>
</li>
<li>小売の場合，全ての人に対して同じ品物を提供するため，失敗しても小額</li>
<li>注文：ビジネスにおける売買
<ul>
<li>選定，見積り，発注，納品，検収，請求，支払い</li>
<li>それぞれの人に対して個別の製品・システムを提供</li>
<li>失敗すると多額の負債</li>
</ul>
</li>
</ul>
<h4 id="営業における顧客のbantbantch">営業における顧客の<strong>BANT</strong>，<strong>BANTCH</strong></h4>
<ul>
<li>Budget：予算
<ul>
<li>払える金額はいくらか，現状の金額はいくらか，費用対効果をどう見積もるか。</li>
</ul>
</li>
<li>Authority：権限のある人
<ul>
<li>担当者か，上司か，社長か，親会社か，社内稟議書が必要か</li>
</ul>
</li>
<li>Needs：必要性
<ul>
<li>発言されたニーズだけでなく真のニーズは何か</li>
</ul>
</li>
<li>Timefreame：導入時期
<ul>
<li>契約，社内決裁，納品，導入の時期，社内会議の時期</li>
</ul>
</li>
<li>Competitor：競合他社
<ul>
<li>他社の見積額は，他社との比較点は</li>
</ul>
</li>
<li>Human resources：社内人材
<ul>
<li>担当者がスキルを持っているか，全体の体制はどうなっているか</li>
</ul>
</li>
</ul>
<h3 id="システム開発のプロジェクト">システム開発のプロジェクト</h3>
<h4 id="システム開発のライフサイクル">システム開発のライフサイクル</h4>
<ul>
<li>要求分析・要件定義
<ul>
<li>顧客の望むこと（要求）を仕様（要件）に落とし込む</li>
</ul>
</li>
<li>外部設計
<ul>
<li>システムの使い方と構成を仕様にする</li>
</ul>
</li>
<li>内部設計
<ul>
<li>実装の方針を決定する</li>
</ul>
</li>
<li>プログラミング
<ul>
<li>実際の開発を行う</li>
</ul>
</li>
<li>テスト
<ul>
<li>品質を保証するための確認を行う</li>
</ul>
</li>
<li>運用・保守
<ul>
<li>納品後のメンテナンスを続ける</li>
</ul>
</li>
</ul>
<h4 id="プロジェクト">プロジェクト</h4>
<ul>
<li>プロジェクト＝ある期間に行われるイベント
<ul>
<li>メンバーはプロジェクト単位で召集される。</li>
<li>プロジェクトが終了したら次のプロジェクトへメンバーは移動する</li>
<li>複数のプロジェクトを掛け持つメンバーもいる</li>
</ul>
</li>
<li>システム開発というプロジェクトの進行を管理する
<ul>
<li>管理者はプロジェクトマネージャ（PM）</li>
<li>国家資格あり</li>
<li>管理する対象：QCD
<ul>
<li>Quality</li>
<li>Costs</li>
<li>Delivery</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="人的資源の管理">人的資源の管理</h4>
<ul>
<li>プロジェクトチームでの開発が必須
<ul>
<li>システムが大規模になると，分担して開発しなければならない
<ul>
<li>Q:品質が保てない（複数人の体系的なチェックが必要）</li>
<li>C：コストが高くなる（単価は低いが多数の人材が必要）</li>
<li>D：間に合わない（システムの分割と並列開発が必要）</li>
</ul>
</li>
</ul>
</li>
<li>人的資源の見積もり：工数（単位：人月）
<ul>
<li>作業量を一人あたりの時間（月）で表す</li>
<li>例：10人月
<ul>
<li>1人で10ヶ月，10人で１ヶ月</li>
</ul>
</li>
<li>スキルには当然個人差がある
<ul>
<li>少数の高スキルの人材は困難な工程へ割り振る</li>
<li>多数の低スキルの人材を容易な工程へ割り振る</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="プロジェクトマネジメント">プロジェクトマネジメント</h4>
<ul>
<li>標準化された方法論：PMBOK
<ul>
<li>名称：プロジェクトマネジメント知識体系（Project Management Body of Knowledge）</li>
<li>発行：プロジェクトマネジメント協会</li>
<li>PMBOK
<ul>
<li>プロセス群：立ち上げ，計画，実行，監視・制御，集結</li>
<li>知識エリア：統合，スコープ，スケジュール，コスト，コミュニケーション，品質，人的資源，リスク，調達，ステークホルダー</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="リスクマネジメント">リスクマネジメント</h4>
<ul>
<li>プロジェクトの進行を阻害する潜在的な要因
<ul>
<li>顧客：要求が曖昧，間違っていた，頻繁に変更する</li>
<li>体制：要員不足，病気・退職などによる減員，スキル不足，自然災害</li>
</ul>
</li>
<li>対処
<ul>
<li>予防：リスクの発生を抑える</li>
<li>回避：リスクの原因を取り除く</li>
<li>転嫁：リスクの影響を第三者に委託</li>
<li>軽減：リスクの影響を抑える</li>
<li>受容：リスクの結果を受け入れる</li>
</ul>
</li>
<li>評価
<ul>
<li>リスク毎に優先順位をつける</li>
<li>発生頻度，影響度を数値化</li>
</ul>
</li>
</ul>
<h4 id="プロセス改善">プロセス改善</h4>
<ul>
<li>プロジェクト管理できる能力の指標：CMMI
<ul>
<li>能力成熟度モデル統合(Capability Maturity Model Integreation)</li>
<li>プロジェクト管理のプロセスが常に改善されるかどうかの指標<br>
　- レベル1：初期段階，場当たり的。<br>
　- レベル2：開発が管理済み，反復して実行が可能。<br>
　- レベル3：標準プロセスが定義済みで，改善されている。<br>
　- レベル4：定量的に管理され，予測が可能。<br>
　- レベル5：プロセス改善が最適化されている。</li>
</ul>
</li>
</ul>
<h4 id="見積もり">見積もり</h4>
<ul>
<li>規模の見積もり
<ul>
<li>経験
<ul>
<li>過去のプロジェクト</li>
</ul>
</li>
<li>LOC（Lines of code）法
<ul>
<li>総コード数，プログラマ一人あたり一ヶ月あたりの生成可能コード数</li>
<li>プログラムステップ法とは</li>
</ul>
</li>
<li>ファンクションポイント（FP）法
<ul>
<li>外部入出力，ユーザーインタラクション，外部インターフェース，使用ファイルなどの各項目の点数（FP）を積算</li>
</ul>
</li>
</ul>
</li>
<li>工数の見積もり
<ul>
<li>経験
<ul>
<li>過去のプロジェクト</li>
</ul>
</li>
<li>COCOMO
<ul>
<li>constructive cost model</li>
<li>統計的なコスト推計モデル
<ul>
<li>LOCから工数への変換式</li>
<li>習熟度や難易度で補正</li>
<li>基本，中間，詳細COCOMO</li>
</ul>
</li>
</ul>
</li>
<li>COCOMOⅡ
<ul>
<li>FPも取り入れる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="形態">形態</h4>
<ul>
<li>開発
<ul>
<li>プロジェクトマネージャー（PM）
<ul>
<li>責任者，企画立案，計画提案，リスク管理，予算獲得や人材確保。</li>
</ul>
</li>
<li>プロジェクトリーダー（PL）
<ul>
<li>PMとほぼ同じ，大規模開発でPMの一部を担う。</li>
</ul>
</li>
<li>システムエンジニア（SE）
<ul>
<li>開発全般を担当。仕様策定と設計が責務。顧客との打ち合わせも行う。</li>
<li>システムの具体的な構成を検討。多方面の知識が必要。</li>
</ul>
</li>
<li>プログラマ（PG）各種エンジニア
<ul>
<li>開発担当，各分野の高度なスキルが必要</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="発注と受注">発注と受注</h3>
<h4 id="発注と受注の形態">発注と受注の形態</h4>
<ul>
<li>呼称
<ul>
<li>発注側：クライアント，ユーザー，カスタマー，顧客，お客様</li>
<li>受注側：ベンダ，業者</li>
</ul>
</li>
<li>受注側がさらに外注する場合
<ul>
<li>発注側：元請け（1次下請け）</li>
<li>受注側：下請け（2次下請け）
<ul>
<li>さらに外注すると3次下請け</li>
<li>多重下請けの大元請けをITゼネコンとも呼ぶ（General contractor承包商）</li>
</ul>
</li>
</ul>
</li>
<li>企業規模
<ul>
<li>大企業：社内にシステム開発を請け負う部門がある</li>
<li>ベンチャー：中小企業：数十人から数百人程度，システム開発専門。</li>
<li>フリーランス：個人で受託開発を請け負う。</li>
</ul>
</li>
</ul>
<h3 id="プロジェクト管理">プロジェクト管理</h3>
<h4 id="プロジェクト進歩管理の初歩">プロジェクト進歩管理の初歩</h4>
<ul>
<li>WBS
<ul>
<li>作業分解構成図（Work Breakdown Structure）</li>
<li>プロジェクトを，必要な全ての作業要素（タスク）に分解・列挙し，管理する
<ul>
<li>モレなくダブりなく（MECE, Mutually Exclusive and Collective）</li>
<li>階層的に分解する
<ul>
<li>大まかな作業（親タスク）の下に，それぞれの細かい作業（小タスク）をぶら下げる</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ガントチャート
<ul>
<li>WBSで列挙した作業要素（タスク）の進歩を管理する</li>
<li>タスク間の順序と進歩を可視化する</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload.wikimedia.org/wikipedia/commons/e/eb/Work_Breakdown_Structure_of_Aircraft_System.jpg" alt="WBS" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://upload.wikimedia.org/wikipedia/commons/8/89/Gantt_Chart_Template_for_Film_Production.png" alt="Gantt Chart" loading="lazy"></figure>
<h4 id="ev分析-evm-earned-value-management">EV分析　EVM 【Earned Value Management】</h4>
<ul>
<li>
<p>アーンドバリュー分析</p>
<ul>
<li>Earned Value (EV) Analysis /Management</li>
<li>コスト，資源，生産性の管理</li>
<li>実績と計画からEVを計算
<ul>
<li>過剰コストと遅れがズレ</li>
</ul>
</li>
<li>WBSの各作業に対して
<ul>
<li>コストを時間を割り当てる</li>
<li>進歩率 = 完了作業 / 全作業</li>
</ul>
</li>
</ul>
</li>
<li>
<p>パラメータ</p>
<ul>
<li>BAC（Budget at Completion）　プロジェクトの総予算</li>
<li>EAC（Estimate At Completion）　完成時そうコスト見積り　現状のまま進歩した場合の最終コストの見積り</li>
<li>EV（Earned Value）出来高
<ul>
<li>完了済みの作業に対する予算コスト</li>
<li>EV = BAC * 進歩率</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Project_Management_%28metriche_di_progetto%29.png" alt="EV" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPAでパラメータで変数の値を渡す方法]]></title>
        <id>https://zzy-tech.github.io/post/A2C8pQJ7y/</id>
        <link href="https://zzy-tech.github.io/post/A2C8pQJ7y/">
        </link>
        <updated>2021-04-10T15:46:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
<!-- more -->
<p><img src="https://zzy-tech.github.io//post-images/1618066009899.png" alt="" loading="lazy"><br>
図で示したように，「?変数の番号」で渡すことができる</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring AOPにおけるPointcut式例]]></title>
        <id>https://zzy-tech.github.io/post/RmuKwXL0F/</id>
        <link href="https://zzy-tech.github.io/post/RmuKwXL0F/">
        </link>
        <updated>2021-03-22T03:28:30.000Z</updated>
        <summary type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
]]></summary>
        <content type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
<!-- more -->
<pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
</code></pre>
<p>publicメソッドの実行</p>
<pre><code>execute(public * *(..))
</code></pre>
<p>setで始まる名前のメソッドの実行</p>
<pre><code>execution(* set*(..))
</code></pre>
<p>AccountServiceインターフェースによって定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.AccountService.*(..))
</code></pre>
<p>serviceパッケージで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.*.*(..))
</code></pre>
<p>サービスパッケージまたはそのサブパッケージのいずれかで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service..*.*(..))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatisを始める：Quick Start]]></title>
        <id>https://zzy-tech.github.io/post/kk4jq6fpX/</id>
        <link href="https://zzy-tech.github.io/post/kk4jq6fpX/">
        </link>
        <updated>2021-03-13T12:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
<!-- more -->
<h2 id="installation">Installation</h2>
<p>Mavenを利用する場合は下記の依存性を追加する。もしくは，mybatis-x.x.x.jarをクラスパスに追加する必要がある。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupID&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="xml形式の設定ファイルを使ってsqlsessionfactoryを生成する">XML形式の設定ファイルを使ってSqlSessionFactoryを生成する</h2>
<p>Mybatisアプリケーションは，SqlSessionFactoryのインスタンスを中心に構成されている。<br>
SqlSessionFactoryのインスランスは，SqlSessionFactoryBuilderを使って取得することができる。<br>
SqlSessionFactoryBuilderがSqlSessionFactoryを生成する際の設定は，XML形式の設定ファイルを読み込むか，独自に用意したConfigurationクラスのインスタンスを渡すことで行う。</p>
<pre><code>String resource = &quot;mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</code></pre>
<p>XML形式の設定ファイルには，Mybatisシステムの基本設定が含まれる。例えば，データベースからConnectionのインスタンスを取得するDataSourceや，トランザクションの制御方法を決定するTransactionManagerなどである。</p>
<p>簡単なサンプル：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;enviroments default=&quot;development&quot;&gt;
        &lt;enviroment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/databaseName?characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;123&quot;&gt;
            &lt;/dataSource&gt;
        &lt;/enviroments&gt;
    &lt;/enviroments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/xxx/xxx/MapperName.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>enviroment要素には，トランザクション管理やコネクションプーリングといった環境依存の設定が含まれている。<br>
mapper要素にはMapperのリストが含まれている。Mapperとは，SQL文とマッピングの定義を含むXMLファイルである。</p>
<h2 id="mapped-sql-statementsについて">Mapped SQL Statementsについて</h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
　PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
　&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>１つのMapper XMLファイルに複数のMapped Statementを定義することができるので，XMLヘッダやdoctype宣言は一度書く。<br>
「org.mybatis.example.BlogMapper」というネームスペース中に「selectBlog」という名前のMapped Statementを定義している。</p>
<p>このMapped Statementを実行するには，以下のように完全修飾名「org.mybatis.example.BlogMapper.selectBlog」を指定してSqlSessionのメソッドを呼び出す。</p>
<pre><code>Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);
</code></pre>
<p>ただし，mybatis-config.xmlに，typeAliasesを追加すれば，完全修飾名を使わずに済む。</p>
<pre><code>&lt;configuration&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.how2java.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;enviroments&gt;
    ...
&lt;/configuration&gt;
</code></pre>
<h2 id="スコープとライフサイクル">スコープとライフサイクル</h2>
<h3 id="sqlsessionfactorybuilder">SqlSessionFactoryBuilder</h3>
<p>このクラスは，インスタンス化し，使用し，破壊することができる。一旦SqlSessionFactoryを生成してしまえば，このクラスを残しておく理由はない。したがって，このクラスのスコープとして最適なのは<strong>メソッドスコープ</strong>（つまり，ローカルメソッド変数）である。<br>
SqlSessionFactoryBuilderを再利用して複数のSqlSessionFactoryを生成することも可能だが，XMLをパースするためのリソースが他の重要なものを圧迫しないように，このクラスを保持して使いまわさない方が得策である。</p>
<h3 id="sqlsessionfactory">SqlSessionFactory</h3>
<p>生成したSqlSessionFactoryは，あなたのアプリケーション実行中はそのまま残しておくべきである。生成したSqlSessionFactoryを破棄したり，再度生成する理由はないはずである。したがって，SqlSessionFactoryに最適なのは<strong>アプリケーションスコープ</strong>である。これを実現する方法はいくつもある。もっとも簡単なのはシングルトンパターンまたはスタティックシングルトンパターンを使う方法である。</p>
<h3 id="sqlsession">SqlSession</h3>
<p>各スレッドは，独立したSqlSessionのインスタンスを使うべきである。SqlSessionのインスタンスは共有されることを前提としていないため，スレッドセーフではない。当然，最適なスコープは<strong>メソッドスコープ</strong>になる。SqlSessionのインスタンスへの参照をstaticなフィールドや，インスタンスフィールドにも格納してはいけない。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zzy-tech.github.io/post/8IAmAkZZ0/</id>
        <link href="https://zzy-tech.github.io/post/8IAmAkZZ0/">
        </link>
        <updated>2021-02-26T08:27:18.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
<!-- more -->
<h2 id="第六章-过滤数据">第六章 过滤数据</h2>
<h3 id="61-使用where子句">6.1 使用WHERE子句</h3>
<pre><code>SELECT prod_name prod_price
FROM products
WHERE prod_price = 2.50;
</code></pre>
<h3 id="62-where子句操作符">6.2 WHERE子句操作符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN ... AND ...</td>
<td style="text-align:left">在指定两值之间</td>
</tr>
</tbody>
</table>
<h4 id="621-~-623">6.2.1 ~ 6.2.3</h4>
<p>测试表格操作符</p>
<h4 id="624-控制检查">6.2.4 控制检查</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_price IS NULL

SELECT prod_name
FROM products
WHERE prod_price IS NOT NULL
</code></pre>
<h2 id="第七章-数据过滤">第七章 数据过滤</h2>
<h3 id="71-组合where子句">7.1 组合WHERE子句</h3>
<h4 id="711-and操作符">7.1.1 AND操作符</h4>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1003 AND prod_price &lt;= 10;
</code></pre>
<h4 id="712-or操作符">7.1.2 OR操作符</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
</code></pre>
<h4 id="713-计算次序">7.1.3 计算次序</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;
</code></pre>
<p>在WHERE子句中使用圆括号：<br>
任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。</p>
<h3 id="73-in操作符">7.3 IN操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002, 1003)
ORDER BY prod_name;
</code></pre>
<p>此语句与使用OR时具有相同的功能</p>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003
ORDER BY prod_name;
</code></pre>
<p>使用IN操作符的优点：</p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚而且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句（详见14章）。</li>
</ul>
<h3 id="73-not操作符">7.3 NOT操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id NOT IN (1002,1003)
ORDER BY prod_name;
</code></pre>
<h2 id="第八章-用通配符进行过滤">第八章 用通配符进行过滤</h2>
<h3 id="81-like操作符">8.1 LIKE操作符</h3>
<h4 id="811-百分号通配符">8.1.1 百分号通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 'jet%';
</code></pre>
<p>搜索jet起头的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '%anvil%';
</code></pre>
<p>搜索含有anvil的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 's%e';
</code></pre>
<p>搜索s开头e结尾的词</p>
<p>注意：<br>
%不能匹配NULL</p>
<h4 id="812-下划线通配符">8.1.2 下划线通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '_ ton anvil';
</code></pre>
<p>_总是匹配一个字符</p>
<h3 id="82-使用通配符的技巧">8.2 使用通配符的技巧</h3>
<p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>除非绝对有必要，否则不要把它们用在搜索模式的开始处。放在开始处的搜索是最慢的。</li>
<li>仔细注意通配符的位置。</li>
</ul>
<h2 id="第九章-使用正则表达式">第九章 使用正则表达式</h2>
<h3 id="92-使用mysql正则表达式">9.2 使用MySQL正则表达式</h3>
<h4 id="921-基本字符匹配">9.2.1 基本字符匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name;
</code></pre>
<p>查询含有1000的名称</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '.000'
ORDER BY prod_name;
</code></pre>
<h4 id="922-进行or匹配">9.2.2 进行OR匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000|2000'
ORDER BY prod_name;
</code></pre>
<h4 id="923-匹配几个字符之一">9.2.3 匹配几个字符之一</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="924-匹配范围">9.2.4 匹配范围</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[1-5] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="925-匹配特殊字符">9.2.5 匹配特殊字符</h4>
<pre><code>SELECT vend_name
FROM vendors
WHERE vend_name REGEXP '\\.'
ORDER BY vend_name;
</code></pre>
<p>为了匹配反斜杠（\）字符本身，要用\\。</p>
<p>MySQL要求两个反斜杠，MySQL自己解释一个，正则表达式库解释另一个。</p>
<h4 id="926-匹配字符类">9.2.6 匹配字符类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td>ASCII控制字符（ASCII0到31和127）</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td>任意小写字母（同[:lower:]）</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td>任意十六进制数字（同a-fA-F0-9）</td>
</tr>
</tbody>
</table>
<h4 id="927-匹配多个实例">9.2.7 匹配多个实例</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（同{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或一个匹配（同{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\([0-9] sticks?\\)'
ORDER BY prod_name;

SELECT prod_name
FROM products
WHERE prod_name REGEXP '[[:digit:]]{4}'
ORDER BY prod_name;
</code></pre>
<p>四个连续的数字，与下面的写法相同</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[0-9][0-9][0-9][0-9]'
ORDER BY prod_name;
</code></pre>
<h4 id="928-定位符">9.2.8 定位符</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '^[0-9\\.]'
ORDER BY prod_name;
</code></pre>
<p>LIKE匹配整个串而REGEXP匹配子串。</p>
<h2 id="第十章-创建拼接字段">第十章 创建拼接字段</h2>
<h3 id="102-拼接字段">10.2 拼接字段</h3>
<pre><code>SELECT Concat(vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;

SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')')
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>RTrim() 去除右边空格<br>
LTrim() 去除左边空格<br>
Trim()  去除两边空格</p>
<pre><code>SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') AS vend_title
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>赋予新计算列别名</p>
<h3 id="103-执行算数计算">10.3 执行算数计算</h3>
<pre><code>SELECT prod_id, quantity, item_price, quantity*item_price AS enpanded_price
FROM orderitems
WHERE order_num = 20005;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
<h2 id="第十一章-使用数据处理函数">第十一章 使用数据处理函数</h2>
<h3 id="112-使用函数">11.2 使用函数</h3>
<h4 id="1121-文本处理函数">11.2.1 文本处理函数</h4>
<pre><code>SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
</code></pre>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody>
</table>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX不是SQL概念，但MySQL提供对其的支持。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE cust_contact = 'Y. Lie';
</code></pre>
<p>此句不会搜索出'Y Lee'，但使用SOUNDEX可搜索出。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE Soundex(cust_contact) = Soundex('Y Lie');
</code></pre>
<h4 id="1122-日期和时间处理函数">11.2.2 日期和时间处理函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddDate()</td>
<td>增加一个日期（天，周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时，分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<p>日期格式必须为yyyy-mm-dd</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
</code></pre>
<p>更可靠的语句：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
</code></pre>
<p>搜索某月的全部订单：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
</code></pre>
<p>或者</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</code></pre>
]]></content>
    </entry>
</feed>