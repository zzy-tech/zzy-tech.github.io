<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzy-tech.github.io/</id>
    <title>听故事的人</title>
    <updated>2022-07-08T03:36:45.110Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzy-tech.github.io/"/>
    <link rel="self" href="https://zzy-tech.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zzy-tech.github.io/images/avatar.png</logo>
    <icon>https://zzy-tech.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[Go学习笔记]]></title>
        <id>https://zzy-tech.github.io/post/wVjJ9Td2t/</id>
        <link href="https://zzy-tech.github.io/post/wVjJ9Td2t/">
        </link>
        <updated>2022-05-06T15:30:11.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Structs are mutable.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About slice]]></title>
        <id>https://zzy-tech.github.io/post/FCxr0jmyz/</id>
        <link href="https://zzy-tech.github.io/post/FCxr0jmyz/">
        </link>
        <updated>2022-05-03T09:36:10.000Z</updated>
        <summary type="html"><![CDATA[<p>In the early development of Go, it took about a year to decide the answers to these questions before the design felt right. The key step was the introduction of slices, which built on fixed-size arrays to give a flexible, extensible data structure. To this day, however, programmers new to Go often stumble over the way slices work, perhaps because experience from other languages has colored their thinking.</p>
]]></summary>
        <content type="html"><![CDATA[<p>In the early development of Go, it took about a year to decide the answers to these questions before the design felt right. The key step was the introduction of slices, which built on fixed-size arrays to give a flexible, extensible data structure. To this day, however, programmers new to Go often stumble over the way slices work, perhaps because experience from other languages has colored their thinking.</p>
<!-- more -->
<p>Resource: https://go.dev/blog/slices</p>
<h2 id="the-slice-header">The slice header</h2>
<p>It’s not quite the full story, but for now think of a slice as a little data structure with two elements: a length and a pointer to an element of an array. You can think of it as being built like this behind the scenes:</p>
<pre><code>type sliceHeader struct {
    Length        int
    ZerothElement *byte
}

slice := sliceHeader{
    Length:        50,
    ZerothElement: &amp;buffer[100],
}
</code></pre>
<h2 id="passing-slice-to-functions">Passing slice to functions</h2>
<p>It’s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.</p>
<pre><code>slashPos := bytes.IndexRune(slice, '/')
</code></pre>
<p>When we called IndexRune in the previous example, it was passed a copy of the slice header. That behavior has important ramifications.</p>
<p><strong>Note</strong>: Even though the slice header is passed by value, the header includes a <strong>pointer to elements of an array</strong>, so both the original slice header and the copy of the header passed to the function describe the same array. Therefore, when the function returns, the modified elements can be seen through the original slice variable.</p>
<h2 id="capacity">Capacity</h2>
<p>Besides the array pointer and length, the slice header also stores its capacity:</p>
<pre><code>type sliceHeader struct {
    Length        int
    Capacity      int
    ZerothElement *byte
}
</code></pre>
<p>The Capacity field records how much space the underlying array actually has; it is the maximum value the Length can reach. Trying to grow the slice beyond its capacity will step beyond the limits of the array and will trigger a panic.</p>
<h2 id="nil">Nil</h2>
<p>As an aside, with our newfound knowledge we can see what the representation of a nil slice is. Naturally, it is the zero value of the slice header:</p>
<pre><code>sliceHeader{
    Length:        0,
    Capacity:      0,
    ZerothElement: nil,
}
</code></pre>
<p>An empty slice can grow (assuming it has non-zero capacity), but a nil slice has no array to put values in and can never grow to hold even one element.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is sequence?]]></title>
        <id>https://zzy-tech.github.io/post/FS9Dkp9hu/</id>
        <link href="https://zzy-tech.github.io/post/FS9Dkp9hu/">
        </link>
        <updated>2022-05-02T13:39:22.000Z</updated>
        <summary type="html"><![CDATA[<p>from http://support.kodable.com/en/articles/417330-what-is-sequence</p>
<p><strong>Definition</strong>:</p>
<p>Sequence, the order that commands are executed by a computer, allows us to carry out tasks that have multiple steps.</p>
]]></summary>
        <content type="html"><![CDATA[<p>from http://support.kodable.com/en/articles/417330-what-is-sequence</p>
<p><strong>Definition</strong>:</p>
<p>Sequence, the order that commands are executed by a computer, allows us to carry out tasks that have multiple steps.</p>
<!-- more -->
<p>In programming, sequence is a basic algorithm: A set of logical steps carried out in order. Computers need instructions in the form of an algorithm in order to complete a desired task, and this algorithm must have the correct order of strps, or sequence.</p>
<p><strong>Why is Sequence Important?</strong> In both programming and day to day tasks, if we don't put every step in the right sequence, the end result isn't what we wanted. Sequence is the most foundational concept in programming, and everything we learn moving forward will build on this concept.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[モジュールが持つ特性]]></title>
        <id>https://zzy-tech.github.io/post/ChAMKuYiO/</id>
        <link href="https://zzy-tech.github.io/post/ChAMKuYiO/">
        </link>
        <updated>2021-05-20T12:58:16.000Z</updated>
        <summary type="html"><![CDATA[<p>モジュール凝集度およびモジュール結合度</p>
]]></summary>
        <content type="html"><![CDATA[<p>モジュール凝集度およびモジュール結合度</p>
<!-- more -->
<h2 id="モジュール凝集度">モジュール凝集度</h2>
<p>モジュールの凝集度は高いものほどよく，情報的もしくは機能的凝集を目標とする。</p>
<h3 id="暗号的-coincidental-cohesion-低">暗号的 Coincidental Cohesion （低）</h3>
<ul>
<li>複数の，無関係な機能をモジュール化したもの</li>
<li>大きさだけで分割，偶然一致している部分を共通モジュール化</li>
</ul>
<h3 id="論理的-logical-cohesion">論理的 Logical Cohesion</h3>
<ul>
<li>複数の機能を一つのモジュールにし，動かすものを外部から指示する形</li>
<li>論理が似ている/呼称が同じだけでモジュール化</li>
</ul>
<h3 id="時間的-classical-cohesion">時間的 Classical Cohesion</h3>
<ul>
<li>複数の実行時間が同じ逐次的な機能を一つのモジュールにまとめたもの</li>
<li>処理タイミングが同じだけでモジュール化</li>
</ul>
<h3 id="手順的-procedural-cohesion">手順的 Procedural Cohesion</h3>
<ul>
<li>複数の関連性を持つ逐次的な機能を一つのモジュールにまとめたもの</li>
<li>コントロールの流れのまとまったひとかたまりをモジュール化</li>
</ul>
<h3 id="連絡的-communicational-cohesion">連絡的 Communicational Cohesion</h3>
<ul>
<li>モジュール内の要素間でデータの受け渡しを行うもの</li>
<li>コントロールの流れ＋扱うデータの流れを考慮してモジュール化</li>
</ul>
<h3 id="情報的-informational-cohesion">情報的 Informational Cohesion</h3>
<ul>
<li>特定のデータ構造を持つ複数の機能をまとめたもの</li>
<li>特定のデータ構造を扱う複数機能をモジュール化</li>
</ul>
<h3 id="機能的-functional-cohesion-高">機能的 Functional Cohesion （高）</h3>
<ul>
<li>全ての要素が一つの機能を実行するために関連しあっているもの</li>
</ul>
<h2 id="モジュールの結合度">モジュールの結合度</h2>
<p>モジュールの結合度は低いものほど良く，スタンプ結合もしくは，データ結合を目標とする。</p>
<h3 id="内容結合">内容結合</h3>
<ul>
<li>他のモジュール内のデータを直接参照したり，直接ブランチしたりする</li>
<li>相手の内容の参照，修正，使用</li>
</ul>
<h3 id="共通結合">共通結合</h3>
<ul>
<li>共通域のデータ構造を参照する</li>
<li>共通データ構造の複数モジュールでの使用</li>
</ul>
<h3 id="外部結合">外部結合</h3>
<ul>
<li>外部宣言しているデータを参照する</li>
<li>共通データを複数モジュールで参照</li>
</ul>
<h3 id="制御結合">制御結合</h3>
<ul>
<li>制御要素がパラメータとして渡される</li>
<li>相手に渡すパラメータで，相手の処理を変更</li>
</ul>
<h3 id="スタンプ結合">スタンプ結合</h3>
<ul>
<li>二つ以上のモジュールが，共通域にはない同じデータを共有する</li>
<li>共通データ構造の複数モジュールに置ける使用であるが，その構造定義はモジュール側に持つ（パラメータで参照）</li>
</ul>
<h3 id="データ結合">データ結合</h3>
<ul>
<li>データ要素のパラメータ受け渡しでインターフェースを取る</li>
<li>モジュール間の関係は，必要なデータのみの受け渡しその値によって相手は影響を受けない</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ソフトウェア工学]]></title>
        <id>https://zzy-tech.github.io/post/1KjJfbkSn/</id>
        <link href="https://zzy-tech.github.io/post/1KjJfbkSn/">
        </link>
        <updated>2021-04-23T17:19:49.000Z</updated>
        <summary type="html"><![CDATA[<p>ソフトウェア工学の概要，システム開発のプロジェクト</p>
]]></summary>
        <content type="html"><![CDATA[<p>ソフトウェア工学の概要，システム開発のプロジェクト</p>
<!-- more -->
<h2 id="第一回">第一回</h2>
<h3 id="概要">概要</h3>
<h4 id="ソフトウェアとは">ソフトウェアとは</h4>
<p>定義：情報処理システムのプログラム，手続き，規則および関連文書の全体または一部分。</p>
<h4 id="ソフトウェアの種類">ソフトウェアの種類</h4>
<ul>
<li>市販ソフトウェア：同一製品
<ul>
<li>パッケージソフト
<ul>
<li>DVDなどの媒体を購入</li>
</ul>
</li>
<li>アプリ
<ul>
<li>アプリストアからダウンロード</li>
</ul>
</li>
<li>クラウドサービス
<ul>
<li>ブラウザなどからアクセス</li>
</ul>
</li>
</ul>
</li>
<li>カスタムソフトウェア：個別製品
<ul>
<li>受託開発，企業システムに利用。</li>
</ul>
</li>
</ul>
<h4 id="システムの例">システムの例</h4>
<p>予約・発券システム，搭乗員シフト管理システム，経営管理システム，採点システムなど。</p>
<h3 id="ソフトウェア工学とシステム開発">ソフトウェア工学とシステム開発</h3>
<h4 id="ソフトウェア工学とは">ソフトウェア工学とは</h4>
<p>ソフトウェアが大規模化，複雑化し，<br>
ソフトウェア開発に工学的な方法を取り入れる取り組み。</p>
<h4 id="ソフトウェア工学">ソフトウェア「工学」</h4>
<ul>
<li>工学であるかどうかは議論の的
<ul>
<li>経験則の集まり，ノウハウのかたまり
<ul>
<li>工学：数式による実世界のモデル化（物理）</li>
<li>ソフトウェア工学：プロジェクト管理による効率的なシステム開発</li>
</ul>
</li>
<li>Wikipediaより
<ul>
<li>もともと，プログラミングおよびシステム分析と呼ばれていた活動などを総称的にsoftware engineeringと呼ぶ。</li>
<li>プログラミングに必要とされる理論的側面をコンピュータ科学と呼び，そうでないあらゆる面をsoftware engineeringと称する。</li>
<li>「プログラミング」を単なる技巧や技能ではなく工学として扱うことを主張する用語であり，そのような指針を文書化したもので使われる。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="工学を導入する理由">工学を導入する理由</h4>
<ul>
<li>ソフトウェアの発注はビジネス契約である
<ul>
<li>コスト，品質，納期が守られる必要がある</li>
</ul>
</li>
<li>小売の場合，全ての人に対して同じ品物を提供するため，失敗しても小額</li>
<li>注文：ビジネスにおける売買
<ul>
<li>選定，見積り，発注，納品，検収，請求，支払い</li>
<li>それぞれの人に対して個別の製品・システムを提供</li>
<li>失敗すると多額の負債</li>
</ul>
</li>
</ul>
<h4 id="営業における顧客のbantbantch">営業における顧客の<strong>BANT</strong>，<strong>BANTCH</strong></h4>
<ul>
<li>Budget：予算
<ul>
<li>払える金額はいくらか，現状の金額はいくらか，費用対効果をどう見積もるか。</li>
</ul>
</li>
<li>Authority：権限のある人
<ul>
<li>担当者か，上司か，社長か，親会社か，社内稟議書が必要か</li>
</ul>
</li>
<li>Needs：必要性
<ul>
<li>発言されたニーズだけでなく真のニーズは何か</li>
</ul>
</li>
<li>Timefreame：導入時期
<ul>
<li>契約，社内決裁，納品，導入の時期，社内会議の時期</li>
</ul>
</li>
<li>Competitor：競合他社
<ul>
<li>他社の見積額は，他社との比較点は</li>
</ul>
</li>
<li>Human resources：社内人材
<ul>
<li>担当者がスキルを持っているか，全体の体制はどうなっているか</li>
</ul>
</li>
</ul>
<h3 id="システム開発のプロジェクト">システム開発のプロジェクト</h3>
<h4 id="システム開発のライフサイクル">システム開発のライフサイクル</h4>
<ul>
<li>要求分析・要件定義
<ul>
<li>顧客の望むこと（要求）を仕様（要件）に落とし込む</li>
</ul>
</li>
<li>外部設計
<ul>
<li>システムの使い方と構成を仕様にする</li>
</ul>
</li>
<li>内部設計
<ul>
<li>実装の方針を決定する</li>
</ul>
</li>
<li>プログラミング
<ul>
<li>実際の開発を行う</li>
</ul>
</li>
<li>テスト
<ul>
<li>品質を保証するための確認を行う</li>
</ul>
</li>
<li>運用・保守
<ul>
<li>納品後のメンテナンスを続ける</li>
</ul>
</li>
</ul>
<h4 id="プロジェクト">プロジェクト</h4>
<ul>
<li>プロジェクト＝ある期間に行われるイベント
<ul>
<li>メンバーはプロジェクト単位で召集される。</li>
<li>プロジェクトが終了したら次のプロジェクトへメンバーは移動する</li>
<li>複数のプロジェクトを掛け持つメンバーもいる</li>
</ul>
</li>
<li>システム開発というプロジェクトの進行を管理する
<ul>
<li>管理者はプロジェクトマネージャ（PM）</li>
<li>国家資格あり</li>
<li>管理する対象：QCD
<ul>
<li>Quality</li>
<li>Costs</li>
<li>Delivery</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="人的資源の管理">人的資源の管理</h4>
<ul>
<li>プロジェクトチームでの開発が必須
<ul>
<li>システムが大規模になると，分担して開発しなければならない
<ul>
<li>Q:品質が保てない（複数人の体系的なチェックが必要）</li>
<li>C：コストが高くなる（単価は低いが多数の人材が必要）</li>
<li>D：間に合わない（システムの分割と並列開発が必要）</li>
</ul>
</li>
</ul>
</li>
<li>人的資源の見積もり：工数（単位：人月）
<ul>
<li>作業量を一人あたりの時間（月）で表す</li>
<li>例：10人月
<ul>
<li>1人で10ヶ月，10人で１ヶ月</li>
</ul>
</li>
<li>スキルには当然個人差がある
<ul>
<li>少数の高スキルの人材は困難な工程へ割り振る</li>
<li>多数の低スキルの人材を容易な工程へ割り振る</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="プロジェクトマネジメント">プロジェクトマネジメント</h4>
<ul>
<li>標準化された方法論：PMBOK
<ul>
<li>名称：プロジェクトマネジメント知識体系（Project Management Body of Knowledge）</li>
<li>発行：プロジェクトマネジメント協会</li>
<li>PMBOK
<ul>
<li>プロセス群：立ち上げ，計画，実行，監視・制御，集結</li>
<li>知識エリア：統合，スコープ，スケジュール，コスト，コミュニケーション，品質，人的資源，リスク，調達，ステークホルダー</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="リスクマネジメント">リスクマネジメント</h4>
<ul>
<li>プロジェクトの進行を阻害する潜在的な要因
<ul>
<li>顧客：要求が曖昧，間違っていた，頻繁に変更する</li>
<li>体制：要員不足，病気・退職などによる減員，スキル不足，自然災害</li>
</ul>
</li>
<li>対処
<ul>
<li>予防：リスクの発生を抑える</li>
<li>回避：リスクの原因を取り除く</li>
<li>転嫁：リスクの影響を第三者に委託</li>
<li>軽減：リスクの影響を抑える</li>
<li>受容：リスクの結果を受け入れる</li>
</ul>
</li>
<li>評価
<ul>
<li>リスク毎に優先順位をつける</li>
<li>発生頻度，影響度を数値化</li>
</ul>
</li>
</ul>
<h4 id="プロセス改善">プロセス改善</h4>
<ul>
<li>プロジェクト管理できる能力の指標：CMMI
<ul>
<li>能力成熟度モデル統合(Capability Maturity Model Integreation)</li>
<li>プロジェクト管理のプロセスが常に改善されるかどうかの指標<br>
　- レベル1：初期段階，場当たり的。<br>
　- レベル2：開発が管理済み，反復して実行が可能。<br>
　- レベル3：標準プロセスが定義済みで，改善されている。<br>
　- レベル4：定量的に管理され，予測が可能。<br>
　- レベル5：プロセス改善が最適化されている。</li>
</ul>
</li>
</ul>
<h4 id="見積もり">見積もり</h4>
<ul>
<li>規模の見積もり
<ul>
<li>経験
<ul>
<li>過去のプロジェクト</li>
</ul>
</li>
<li>LOC（Lines of code）法
<ul>
<li>総コード数，プログラマ一人あたり一ヶ月あたりの生成可能コード数</li>
<li>プログラムステップ法とは</li>
</ul>
</li>
<li>ファンクションポイント（FP）法
<ul>
<li>外部入出力，ユーザーインタラクション，外部インターフェース，使用ファイルなどの各項目の点数（FP）を積算</li>
</ul>
</li>
</ul>
</li>
<li>工数の見積もり
<ul>
<li>経験
<ul>
<li>過去のプロジェクト</li>
</ul>
</li>
<li>COCOMO
<ul>
<li>constructive cost model</li>
<li>統計的なコスト推計モデル
<ul>
<li>LOCから工数への変換式</li>
<li>習熟度や難易度で補正</li>
<li>基本，中間，詳細COCOMO</li>
</ul>
</li>
</ul>
</li>
<li>COCOMOⅡ
<ul>
<li>FPも取り入れる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="形態">形態</h4>
<ul>
<li>開発
<ul>
<li>プロジェクトマネージャー（PM）
<ul>
<li>責任者，企画立案，計画提案，リスク管理，予算獲得や人材確保。</li>
</ul>
</li>
<li>プロジェクトリーダー（PL）
<ul>
<li>PMとほぼ同じ，大規模開発でPMの一部を担う。</li>
</ul>
</li>
<li>システムエンジニア（SE）
<ul>
<li>開発全般を担当。仕様策定と設計が責務。顧客との打ち合わせも行う。</li>
<li>システムの具体的な構成を検討。多方面の知識が必要。</li>
</ul>
</li>
<li>プログラマ（PG）各種エンジニア
<ul>
<li>開発担当，各分野の高度なスキルが必要</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="発注と受注">発注と受注</h3>
<h4 id="発注と受注の形態">発注と受注の形態</h4>
<ul>
<li>呼称
<ul>
<li>発注側：クライアント，ユーザー，カスタマー，顧客，お客様</li>
<li>受注側：ベンダ，業者</li>
</ul>
</li>
<li>受注側がさらに外注する場合
<ul>
<li>発注側：元請け（1次下請け）</li>
<li>受注側：下請け（2次下請け）
<ul>
<li>さらに外注すると3次下請け</li>
<li>多重下請けの大元請けをITゼネコンとも呼ぶ（General contractor承包商）</li>
</ul>
</li>
</ul>
</li>
<li>企業規模
<ul>
<li>大企業：社内にシステム開発を請け負う部門がある</li>
<li>ベンチャー：中小企業：数十人から数百人程度，システム開発専門。</li>
<li>フリーランス：個人で受託開発を請け負う。</li>
</ul>
</li>
</ul>
<h3 id="プロジェクト管理">プロジェクト管理</h3>
<h4 id="プロジェクト進歩管理の初歩">プロジェクト進歩管理の初歩</h4>
<ul>
<li>WBS
<ul>
<li>作業分解構成図（Work Breakdown Structure）</li>
<li>プロジェクトを，必要な全ての作業要素（タスク）に分解・列挙し，管理する
<ul>
<li>モレなくダブりなく（MECE, Mutually Exclusive and Collective）</li>
<li>階層的に分解する
<ul>
<li>大まかな作業（親タスク）の下に，それぞれの細かい作業（小タスク）をぶら下げる</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ガントチャート
<ul>
<li>WBSで列挙した作業要素（タスク）の進歩を管理する</li>
<li>タスク間の順序と進歩を可視化する</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload.wikimedia.org/wikipedia/commons/e/eb/Work_Breakdown_Structure_of_Aircraft_System.jpg" alt="WBS" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://upload.wikimedia.org/wikipedia/commons/8/89/Gantt_Chart_Template_for_Film_Production.png" alt="Gantt Chart" loading="lazy"></figure>
<h4 id="ev分析-evm-earned-value-management">EV分析　EVM 【Earned Value Management】</h4>
<ul>
<li>
<p>アーンドバリュー分析</p>
<ul>
<li>Earned Value (EV) Analysis /Management</li>
<li>コスト，資源，生産性の管理</li>
<li>実績と計画からEVを計算
<ul>
<li>過剰コストと遅れがズレ</li>
</ul>
</li>
<li>WBSの各作業に対して
<ul>
<li>コストを時間を割り当てる</li>
<li>進歩率 = 完了作業 / 全作業</li>
</ul>
</li>
</ul>
</li>
<li>
<p>パラメータ</p>
<ul>
<li>BAC（Budget at Completion）　プロジェクトの総予算</li>
<li>EAC（Estimate At Completion）　完成時そうコスト見積り　現状のまま進歩した場合の最終コストの見積り</li>
<li>EV（Earned Value）出来高
<ul>
<li>完了済みの作業に対する予算コスト</li>
<li>EV = BAC * 進歩率</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Project_Management_%28metriche_di_progetto%29.png" alt="EV" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPAでパラメータで変数の値を渡す方法]]></title>
        <id>https://zzy-tech.github.io/post/A2C8pQJ7y/</id>
        <link href="https://zzy-tech.github.io/post/A2C8pQJ7y/">
        </link>
        <updated>2021-04-10T15:46:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring Data JPAでORマッパーではかけないようなSQLを実行したい場合，Repositoryに直接構文を書き，この時にパラメータで変数の値をどうやったら渡せるでしょうか</p>
<!-- more -->
<p><img src="https://zzy-tech.github.io//post-images/1618066009899.png" alt="" loading="lazy"><br>
図で示したように，「?変数の番号」で渡すことができる</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring AOPにおけるPointcut式例]]></title>
        <id>https://zzy-tech.github.io/post/RmuKwXL0F/</id>
        <link href="https://zzy-tech.github.io/post/RmuKwXL0F/">
        </link>
        <updated>2021-03-22T03:28:30.000Z</updated>
        <summary type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
]]></summary>
        <content type="html"><![CDATA[<p>ポイントカットとは，ジョインポイントに一致する述語である。アドバイスはポイントカット式に関連づけられ，ポイントカットに一致する任意のジョインポイントで実行される。ポイントカット式と一致するジョインポイントの概念はAOPの中心であり，SpringはデフォルトでAspectJポイントカット式言語を使用する。</p>
<!-- more -->
<pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
</code></pre>
<p>publicメソッドの実行</p>
<pre><code>execute(public * *(..))
</code></pre>
<p>setで始まる名前のメソッドの実行</p>
<pre><code>execution(* set*(..))
</code></pre>
<p>AccountServiceインターフェースによって定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.AccountService.*(..))
</code></pre>
<p>serviceパッケージで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service.*.*(..))
</code></pre>
<p>サービスパッケージまたはそのサブパッケージのいずれかで定義されたメソッドの実行</p>
<pre><code>execution(* com.xyz.service..*.*(..))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatisを始める：Quick Start]]></title>
        <id>https://zzy-tech.github.io/post/kk4jq6fpX/</id>
        <link href="https://zzy-tech.github.io/post/kk4jq6fpX/">
        </link>
        <updated>2021-03-13T12:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MyBatis はカスタム SQL，ストアドプロシージャ，高度なマッピング処理に対応した優れた永続化フレームワークである。MyBatisを使うことで、直接 JDBC を扱うコードを書いたり、クエリ引数やクエリ結果を手動で設定する必要がほとんどなくなる。</p>
<!-- more -->
<h2 id="installation">Installation</h2>
<p>Mavenを利用する場合は下記の依存性を追加する。もしくは，mybatis-x.x.x.jarをクラスパスに追加する必要がある。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupID&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="xml形式の設定ファイルを使ってsqlsessionfactoryを生成する">XML形式の設定ファイルを使ってSqlSessionFactoryを生成する</h2>
<p>Mybatisアプリケーションは，SqlSessionFactoryのインスタンスを中心に構成されている。<br>
SqlSessionFactoryのインスランスは，SqlSessionFactoryBuilderを使って取得することができる。<br>
SqlSessionFactoryBuilderがSqlSessionFactoryを生成する際の設定は，XML形式の設定ファイルを読み込むか，独自に用意したConfigurationクラスのインスタンスを渡すことで行う。</p>
<pre><code>String resource = &quot;mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</code></pre>
<p>XML形式の設定ファイルには，Mybatisシステムの基本設定が含まれる。例えば，データベースからConnectionのインスタンスを取得するDataSourceや，トランザクションの制御方法を決定するTransactionManagerなどである。</p>
<p>簡単なサンプル：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;enviroments default=&quot;development&quot;&gt;
        &lt;enviroment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/databaseName?characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;123&quot;&gt;
            &lt;/dataSource&gt;
        &lt;/enviroments&gt;
    &lt;/enviroments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/xxx/xxx/MapperName.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>enviroment要素には，トランザクション管理やコネクションプーリングといった環境依存の設定が含まれている。<br>
mapper要素にはMapperのリストが含まれている。Mapperとは，SQL文とマッピングの定義を含むXMLファイルである。</p>
<h2 id="mapped-sql-statementsについて">Mapped SQL Statementsについて</h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
　PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
　&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>１つのMapper XMLファイルに複数のMapped Statementを定義することができるので，XMLヘッダやdoctype宣言は一度書く。<br>
「org.mybatis.example.BlogMapper」というネームスペース中に「selectBlog」という名前のMapped Statementを定義している。</p>
<p>このMapped Statementを実行するには，以下のように完全修飾名「org.mybatis.example.BlogMapper.selectBlog」を指定してSqlSessionのメソッドを呼び出す。</p>
<pre><code>Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);
</code></pre>
<p>ただし，mybatis-config.xmlに，typeAliasesを追加すれば，完全修飾名を使わずに済む。</p>
<pre><code>&lt;configuration&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.how2java.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;enviroments&gt;
    ...
&lt;/configuration&gt;
</code></pre>
<h2 id="スコープとライフサイクル">スコープとライフサイクル</h2>
<h3 id="sqlsessionfactorybuilder">SqlSessionFactoryBuilder</h3>
<p>このクラスは，インスタンス化し，使用し，破壊することができる。一旦SqlSessionFactoryを生成してしまえば，このクラスを残しておく理由はない。したがって，このクラスのスコープとして最適なのは<strong>メソッドスコープ</strong>（つまり，ローカルメソッド変数）である。<br>
SqlSessionFactoryBuilderを再利用して複数のSqlSessionFactoryを生成することも可能だが，XMLをパースするためのリソースが他の重要なものを圧迫しないように，このクラスを保持して使いまわさない方が得策である。</p>
<h3 id="sqlsessionfactory">SqlSessionFactory</h3>
<p>生成したSqlSessionFactoryは，あなたのアプリケーション実行中はそのまま残しておくべきである。生成したSqlSessionFactoryを破棄したり，再度生成する理由はないはずである。したがって，SqlSessionFactoryに最適なのは<strong>アプリケーションスコープ</strong>である。これを実現する方法はいくつもある。もっとも簡単なのはシングルトンパターンまたはスタティックシングルトンパターンを使う方法である。</p>
<h3 id="sqlsession">SqlSession</h3>
<p>各スレッドは，独立したSqlSessionのインスタンスを使うべきである。SqlSessionのインスタンスは共有されることを前提としていないため，スレッドセーフではない。当然，最適なスコープは<strong>メソッドスコープ</strong>になる。SqlSessionのインスタンスへの参照をstaticなフィールドや，インスタンスフィールドにも格納してはいけない。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://zzy-tech.github.io/post/8IAmAkZZ0/</id>
        <link href="https://zzy-tech.github.io/post/8IAmAkZZ0/">
        </link>
        <updated>2021-02-26T08:27:18.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL必知必会总结<br>
MySQL是最流行的关系型数据库管理系统。</p>
<!-- more -->
<h2 id="第六章-过滤数据">第六章 过滤数据</h2>
<h3 id="61-使用where子句">6.1 使用WHERE子句</h3>
<pre><code>SELECT prod_name prod_price
FROM products
WHERE prod_price = 2.50;
</code></pre>
<h3 id="62-where子句操作符">6.2 WHERE子句操作符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left">BETWEEN ... AND ...</td>
<td style="text-align:left">在指定两值之间</td>
</tr>
</tbody>
</table>
<h4 id="621-~-623">6.2.1 ~ 6.2.3</h4>
<p>测试表格操作符</p>
<h4 id="624-控制检查">6.2.4 控制检查</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_price IS NULL

SELECT prod_name
FROM products
WHERE prod_price IS NOT NULL
</code></pre>
<h2 id="第七章-数据过滤">第七章 数据过滤</h2>
<h3 id="71-组合where子句">7.1 组合WHERE子句</h3>
<h4 id="711-and操作符">7.1.1 AND操作符</h4>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM products
WHERE vend_id = 1003 AND prod_price &lt;= 10;
</code></pre>
<h4 id="712-or操作符">7.1.2 OR操作符</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
</code></pre>
<h4 id="713-计算次序">7.1.3 计算次序</h4>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;
</code></pre>
<p>在WHERE子句中使用圆括号：<br>
任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。</p>
<h3 id="73-in操作符">7.3 IN操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002, 1003)
ORDER BY prod_name;
</code></pre>
<p>此语句与使用OR时具有相同的功能</p>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003
ORDER BY prod_name;
</code></pre>
<p>使用IN操作符的优点：</p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚而且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句（详见14章）。</li>
</ul>
<h3 id="73-not操作符">7.3 NOT操作符</h3>
<pre><code>SELECT prod_name, prod_price
FROM products
WHERE vend_id NOT IN (1002,1003)
ORDER BY prod_name;
</code></pre>
<h2 id="第八章-用通配符进行过滤">第八章 用通配符进行过滤</h2>
<h3 id="81-like操作符">8.1 LIKE操作符</h3>
<h4 id="811-百分号通配符">8.1.1 百分号通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 'jet%';
</code></pre>
<p>搜索jet起头的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '%anvil%';
</code></pre>
<p>搜索含有anvil的词</p>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 's%e';
</code></pre>
<p>搜索s开头e结尾的词</p>
<p>注意：<br>
%不能匹配NULL</p>
<h4 id="812-下划线通配符">8.1.2 下划线通配符</h4>
<pre><code>SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE '_ ton anvil';
</code></pre>
<p>_总是匹配一个字符</p>
<h3 id="82-使用通配符的技巧">8.2 使用通配符的技巧</h3>
<p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>除非绝对有必要，否则不要把它们用在搜索模式的开始处。放在开始处的搜索是最慢的。</li>
<li>仔细注意通配符的位置。</li>
</ul>
<h2 id="第九章-使用正则表达式">第九章 使用正则表达式</h2>
<h3 id="92-使用mysql正则表达式">9.2 使用MySQL正则表达式</h3>
<h4 id="921-基本字符匹配">9.2.1 基本字符匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name;
</code></pre>
<p>查询含有1000的名称</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '.000'
ORDER BY prod_name;
</code></pre>
<h4 id="922-进行or匹配">9.2.2 进行OR匹配</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000|2000'
ORDER BY prod_name;
</code></pre>
<h4 id="923-匹配几个字符之一">9.2.3 匹配几个字符之一</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="924-匹配范围">9.2.4 匹配范围</h4>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[1-5] Ton'
ORDER BY prod_name;
</code></pre>
<h4 id="925-匹配特殊字符">9.2.5 匹配特殊字符</h4>
<pre><code>SELECT vend_name
FROM vendors
WHERE vend_name REGEXP '\\.'
ORDER BY vend_name;
</code></pre>
<p>为了匹配反斜杠（\）字符本身，要用\\。</p>
<p>MySQL要求两个反斜杠，MySQL自己解释一个，正则表达式库解释另一个。</p>
<h4 id="926-匹配字符类">9.2.6 匹配字符类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td>ASCII控制字符（ASCII0到31和127）</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td>任意小写字母（同[:lower:]）</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td>任意十六进制数字（同a-fA-F0-9）</td>
</tr>
</tbody>
</table>
<h4 id="927-匹配多个实例">9.2.7 匹配多个实例</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（同{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或一个匹配（同{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '\\([0-9] sticks?\\)'
ORDER BY prod_name;

SELECT prod_name
FROM products
WHERE prod_name REGEXP '[[:digit:]]{4}'
ORDER BY prod_name;
</code></pre>
<p>四个连续的数字，与下面的写法相同</p>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '[0-9][0-9][0-9][0-9]'
ORDER BY prod_name;
</code></pre>
<h4 id="928-定位符">9.2.8 定位符</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody>
</table>
<pre><code>SELECT prod_name
FROM products
WHERE prod_name REGEXP '^[0-9\\.]'
ORDER BY prod_name;
</code></pre>
<p>LIKE匹配整个串而REGEXP匹配子串。</p>
<h2 id="第十章-创建拼接字段">第十章 创建拼接字段</h2>
<h3 id="102-拼接字段">10.2 拼接字段</h3>
<pre><code>SELECT Concat(vend_name, '(', vend_country, ')')
FROM vendors
ORDER BY vend_name;

SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')')
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>RTrim() 去除右边空格<br>
LTrim() 去除左边空格<br>
Trim()  去除两边空格</p>
<pre><code>SELECT Concat(RTrim(vend_name),'(',RTrim(vend_country),')') AS vend_title
FROM vendors
ORDER BY vend_name;
</code></pre>
<p>赋予新计算列别名</p>
<h3 id="103-执行算数计算">10.3 执行算数计算</h3>
<pre><code>SELECT prod_id, quantity, item_price, quantity*item_price AS enpanded_price
FROM orderitems
WHERE order_num = 20005;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
<h2 id="第十一章-使用数据处理函数">第十一章 使用数据处理函数</h2>
<h3 id="112-使用函数">11.2 使用函数</h3>
<h4 id="1121-文本处理函数">11.2.1 文本处理函数</h4>
<pre><code>SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
</code></pre>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody>
</table>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX不是SQL概念，但MySQL提供对其的支持。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE cust_contact = 'Y. Lie';
</code></pre>
<p>此句不会搜索出'Y Lee'，但使用SOUNDEX可搜索出。</p>
<pre><code>SELECT cust_name, cust_contact
FROM customers
WHERE Soundex(cust_contact) = Soundex('Y Lie');
</code></pre>
<h4 id="1122-日期和时间处理函数">11.2.2 日期和时间处理函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddDate()</td>
<td>增加一个日期（天，周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时，分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<p>日期格式必须为yyyy-mm-dd</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
</code></pre>
<p>更可靠的语句：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
</code></pre>
<p>搜索某月的全部订单：</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
</code></pre>
<p>或者</p>
<pre><code>SELECT cust_id, order_num
FROM orders
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[デバッガコマンド]]></title>
        <id>https://zzy-tech.github.io/post/uDwPfDRbx/</id>
        <link href="https://zzy-tech.github.io/post/uDwPfDRbx/">
        </link>
        <updated>2021-02-15T08:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>gdb Filename.exe</p>
<table>
<thead>
<tr>
<th style="text-align:left">コマンド</th>
<th style="text-align:left">略称</th>
<th style="text-align:left">例</th>
<th style="text-align:left">例示コマンドの機能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">quit</td>
<td style="text-align:left">q</td>
<td style="text-align:left">q</td>
<td style="text-align:left">デバッガを終了</td>
</tr>
<tr>
<td style="text-align:left">help</td>
<td style="text-align:left">h</td>
<td style="text-align:left">h list</td>
<td style="text-align:left">コマンドの説明</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">file</td>
<td style="text-align:left">file e4-3-x64-g.exe</td>
<td style="text-align:left">デバッグ対象を指定</td>
</tr>
<tr>
<td style="text-align:left">set logging</td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging file e4-3a-x64g.log</td>
<td style="text-align:left">ログファイル名を変更</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging overwrite</td>
<td style="text-align:left">ログファイル上書き指定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging overwrite off</td>
<td style="text-align:left">ログファイル追記指定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging on</td>
<td style="text-align:left">ログ記録の有効化</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">set logging off</td>
<td style="text-align:left">ログ記録の無効化</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left"></td>
<td style="text-align:left">target remote:1234</td>
<td style="text-align:left">通信ポート1234を使い遠隔端末に接続</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">l</td>
<td style="text-align:left">l main</td>
<td style="text-align:left">関数mainのコードを10行表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">l</td>
<td style="text-align:left">次の10行表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">l 10</td>
<td style="text-align:left">ソースコードの10行目前後を表示</td>
</tr>
<tr>
<td style="text-align:left">info</td>
<td style="text-align:left">i</td>
<td style="text-align:left">i register</td>
<td style="text-align:left">全レジスタの内容を表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">i register $eax</td>
<td style="text-align:left">レジスタeaxを表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">i break</td>
<td style="text-align:left">ブレークポイントを一覧表示</td>
</tr>
<tr>
<td style="text-align:left">backtrace</td>
<td style="text-align:left">bt</td>
<td style="text-align:left">bt</td>
<td style="text-align:left">バックトレースしスタックフレーム表示</td>
</tr>
<tr>
<td style="text-align:left">disas</td>
<td style="text-align:left"></td>
<td style="text-align:left">disas</td>
<td style="text-align:left">実行中の関数のコードを逆アセンブル</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">disas max3</td>
<td style="text-align:left">関数max3のコードを逆アセンブル</td>
</tr>
<tr>
<td style="text-align:left">where</td>
<td style="text-align:left"></td>
<td style="text-align:left">where</td>
<td style="text-align:left">中断地点を表示</td>
</tr>
<tr>
<td style="text-align:left">run</td>
<td style="text-align:left">r</td>
<td style="text-align:left">r</td>
<td style="text-align:left">プログラムを実行開始</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">r 3 5</td>
<td style="text-align:left">コマンドライン引数(3,5)を指定してプログラムを実行開始</td>
</tr>
<tr>
<td style="text-align:left">break</td>
<td style="text-align:left">b</td>
<td style="text-align:left">b main</td>
<td style="text-align:left">関数mainの先頭にブレイクポイントを設定</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">b 10</td>
<td style="text-align:left">10行目にブレイクポイントを設定</td>
</tr>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">d</td>
<td style="text-align:left">d 2</td>
<td style="text-align:left">2番目のブレイクポイントを解除</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">d</td>
<td style="text-align:left">全ブレイクポイントを解除</td>
</tr>
<tr>
<td style="text-align:left">continue</td>
<td style="text-align:left">c</td>
<td style="text-align:left">c</td>
<td style="text-align:left">中断中のプログラムの実行再開</td>
</tr>
<tr>
<td style="text-align:left">step</td>
<td style="text-align:left">s</td>
<td style="text-align:left">s</td>
<td style="text-align:left">1ステップ（１命令）実行</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">s 10</td>
<td style="text-align:left">10ステップ（10命令）実行</td>
</tr>
<tr>
<td style="text-align:left">display/fmt</td>
<td style="text-align:left">disp</td>
<td style="text-align:left">display/x $eax</td>
<td style="text-align:left">中断ごとにレジスタeaxの値を16進数表示する</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">disp/t a1</td>
<td style="text-align:left">中断ごとに変数a1の値を2進数表示</td>
</tr>
<tr>
<td style="text-align:left">x/fmt</td>
<td style="text-align:left">x</td>
<td style="text-align:left">x/x　0x400606</td>
<td style="text-align:left">0x400606番地から4バイトを16進数表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">x/t $eax</td>
<td style="text-align:left">レジスタeaxの値を2進数表示</td>
</tr>
<tr>
<td style="text-align:left">print/fmt</td>
<td style="text-align:left">p</td>
<td style="text-align:left">p/x $eax</td>
<td style="text-align:left">レジスタeaxの値を16進数表示</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">p i</td>
<td style="text-align:left">変数iの値を10進数表示</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left"></td>
<td style="text-align:left">set v1 = 10</td>
<td style="text-align:left">変数v1の値を10にする</td>
</tr>
</tbody>
</table>
<p>fmt：書式指定</p>
<ul>
<li>t:2進数</li>
<li>o:8進数</li>
<li>d:10進数</li>
<li>x:16進数</li>
<li>c:文字</li>
<li>f:浮動小数店</li>
</ul>
]]></content>
    </entry>
</feed>